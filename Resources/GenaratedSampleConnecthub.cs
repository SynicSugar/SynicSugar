// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY SynicSugarGenerator. DO NOT CHANGE IT.
// </auto-generated>
#pragma warning disable CS0164 // This label has not been referenced
#pragma warning disable CS0436 // Type conflicts with the imported type

using UnityEngine;
using MemoryPack;
using MemoryPack.Compression;
using System;
using System.Collections.Generic;
using System.Threading;
using Cysharp.Threading.Tasks;
using Epic.OnlineServices;
using SynicSugar.RTC;
namespace SynicSugar.P2P {
    internal sealed class ConnectHub : IPacketConvert {
        //Singleton
        private static Lazy<ConnectHub> instance = new Lazy<ConnectHub>(() => new ConnectHub());
        public static ConnectHub Instance => instance.Value;

        private ConnectHub(){
            syncTokenSource = new CancellationTokenSource();
        }
        INetworkCore _networkCore;
        INetworkCore NetworkCore { 
            get { 
                if(_networkCore == null){
                    _networkCore = p2pConfig.Instance.GetNetworkCore();
                }
                return _networkCore;
            }
        }
        /// <summary>
        /// SyncToken is managed with the connection's valid state.
        /// </summary>
        CancellationTokenSource syncTokenSource;

        public CancellationToken GetSyncToken(){
            return syncTokenSource.Token;
        }

        void Dispose() {
            syncTokenSource?.Cancel();
            syncTokenSource?.Dispose();
            _networkCore = null;
        }
        /// <summary>
        /// Disposes of the ConnectHub instance and its associated data. <br />
        /// GC-managed data is explicitly disposed here as well, since this is called at a timing where processing overhead is not a concern.
        /// </summary>
        void ResetInstance() {
            Dispose();
            ClearReferenceDictionaries();
            instance = new Lazy<ConnectHub>(() => new ConnectHub());
        }
        //Start
        /// <summary>
        /// Start the packet receiver. Call after creating the Network Instance required for reception.<br />
        /// This cannot be called with other Receiver same time. If start the other Receiver, ConenctHub stop this Receiver automatically before start the new one.
        /// </summary>
        /// <param name="receiveTiming">The timing that packet receiver gets packet from buffer.</param>
        /// <param name="maxBatchSize">How many times during 1 FPS are received</param>
        public Result StartPacketReceiver(PacketReceiveTiming receiveTiming = PacketReceiveTiming.Update, uint maxBatchSize = 1){
        #if SYNICSUGAR_PACKETINFO
            string chs = string.Empty;
            string[] chList = Enum.GetNames(typeof(ConnectHub.Channels));
            foreach(var l in chList){
                chs += l.ToString() + ", ";
            }
            Debug.Log($"ch info: amount {chList.Length} / {chs}");
        #endif
            return NetworkCore.StartPacketReceiver(this, receiveTiming, maxBatchSize);
        }
        
        /// <summary>
        /// To get only SynicPacket in burst FPS. Call after creating the Network Instance required for reception.<br />
        /// This cannot be called with other Receiver same time. If start the other Receiver, ConenctHub stop this Receiver automatically before start the new one.
        /// </summary>
        /// <param name="maxBatchSize">How many times during 1 FPS are received</param>
        public Result StartSynicReceiver(uint maxBatchSize = 1){
            return NetworkCore.StartSynicReceiver(this, maxBatchSize);
        }
        //Pause receiver
        /// <summary>
        /// Pause getting a packet from the buffer. To re-start, call StartPacketReceiver().<br />
        /// *Packet receiving to the buffer is continue. If the packet is over the buffer, subsequent packets are discarded.
        /// </summary>
        [Obsolete("This is old. StopPacketReceiver is new one.")] 
        public Result PausePacketReceiver(){
            return NetworkCore.StopPacketReceiver();
        }
        //Stop receiver
        /// <summary>
        /// Stop getting a packet from the buffer. To re-start, call StartPacketReceiver().<br />
        /// *Packet receiving to the buffer is continue. If the packet is over the buffer, subsequent packets are discarded.
        /// </summary>
        public Result StopPacketReceiver(){
            return NetworkCore.StopPacketReceiver();
        }

        //Pause Reciving buffer
        /// <summary>
        /// Pause receiving a packet to the receive buffer. To re-start, call RestartConnections(). <br />
        /// After call this, packets will have been discarded until connection will re-open.
        /// </summary>
        /// <param name="isForced">If True, force to stop and clear current packet queue. <br />
        /// If false, process current queue, then stop it.</param>
        public async UniTask<Result> PauseConnections(bool isForced = false, CancellationToken cancelToken = default(CancellationToken)){
            syncTokenSource.Cancel();
            return await NetworkCore.PauseConnections(isForced, cancelToken);
        }
        /// <summary>
        /// Prepare to receive packets in advance. If user sent a packet, it can also open connection to get packets without this.
        /// </summary>
        public Result RestartConnections(){
            NetworkCore.RestartConnections();
            syncTokenSource = new CancellationTokenSource();
            return StartPacketReceiver();
        }
        
        /// <summary>
        /// Stop receiver, close all connections and remove the notify events.
        /// Then, the user leave the lobby. The last user closes the lobby in Backend. <br />
        /// If the host calls this method to leave the Lobby, a host migration will occur, assigning a new host.
        /// <param name="destroyManager">Destroy NetworkManager after exit lobby.</param>
        /// <param name="cleanupMemberCountChanged">Need to call MatchMakeManager.Instance.MatchMakingGUIEvents.LobbyMemberCountChanged(id, false) after exit lobby?</param>
        /// <param name="cancelToken">Cancel token for this task</param>
        /// </summary>
        public async UniTask<Result> ExitSession(bool destroyManager = true, bool cleanupMemberCountChanged = false, CancellationToken cancelToken = default(CancellationToken)){
            Result result = await NetworkCore.ExitSession(destroyManager, cleanupMemberCountChanged, cancelToken);
            
            if(result == Result.Success){
                ResetInstance();
            }
            return result;
        }
        /// <summary>
        /// Stop receiver, close all connections and remove the notify events. Then, Host closes and Guest leaves the Lobby.ã€€<br />
        /// When Host closes Lobby, Guests are automatically kicked out from the Lobby. <br />
        /// If the Lobby is closed with this API during a session, the Lobby will be destroyed, ending all peer-to-peer connections not only between the Host and Guests but also among Guests. Following this, ConnectionNotifier will invoke OnLobbyClosed with the Reason.LobbyClosed.
        /// <param name="destroyManager">Destroy NetworkManager after exit lobby.</param>
        /// <param name="cleanupMemberCountChanged">Need to call MatchMakeManager.Instance.MatchMakingGUIEvents.LobbyMemberCountChanged(id, false) after exit lobby?</param>
        /// <param name="cancelToken">Cancel token for this task</param>
        /// </summary>
        public async UniTask<Result> CloseSession(bool destroyManager = true, bool cleanupMemberCountChanged = false, CancellationToken cancelToken = default(CancellationToken)){
            Result result = await NetworkCore.CloseSession(destroyManager, cleanupMemberCountChanged, cancelToken);
            
            if(result == Result.Success){
                ResetInstance();
            }
            
            return result;
        }

        /// <summary>
        /// Destory offline-lobby and stop offline mode.<br />
        /// This process is valid only when a session is created by CreateOfflineLobby.
        /// <param name="destroyManager">Destroy NetworkManager after exit lobby.</param>
        /// <param name="cleanupMemberCountChanged">Need to call MatchMakeManager.Instance.MatchMakingGUIEvents.LobbyMemberCountChanged(id, false) after exit lobby?</param>
        /// <param name="cancelToken">Cancel token for this task</param>
        /// </summary>
        public async UniTask<Result> DestoryOfflineLobby(bool destroyManager = true, bool cleanupMemberCountChanged = false, CancellationToken cancelToken = default(CancellationToken)){
            Result result = await NetworkCore.DestoryOfflineLobby(destroyManager, cleanupMemberCountChanged, cancelToken);

            if(result == Result.Success){
                ResetInstance();
            }
            
            return result;
        }

        [Obsolete("This is old. Channels is new one")]
        public enum CHANNELLIST {
            UpdateChatText, UpdateName, SendLargePacketViaRpc, SetPlayerStatus, SetDataAfterReconnect, Ready, Move, Turn, Stop, StartCharge, Fire, TakeDamage, correctedPlayerPosition, correctedPlayerQuaternion, ReflectDamage, UpdateChat, StartNewGame, currentTime, SetTimestamp, StopTimer, UserList = 252, ObtainPing = 253, ReturnPong = 254, Synic = 255
        }
        //(for elements)
        /// <summary>
        /// Ch's list allocated for SendPacket.
        /// </summary>
        public enum Channels {
            UpdateChatText, UpdateName, SendLargePacketViaRpc, SetPlayerStatus, SetDataAfterReconnect, Ready, Move, Turn, Stop, StartCharge, Fire, TakeDamage, correctedPlayerPosition, correctedPlayerQuaternion, ReflectDamage, UpdateChat, StartNewGame, currentTime, SetTimestamp, StopTimer, UserList = 252, ObtainPing = 253, ReturnPong = 254, Synic = 255
        }
        //For Synic(UserId, value)
        Dictionary<string, byte[]> synicBuffer = new Dictionary<string, byte[]>();
        Dictionary<string, SynicPacketInfomation> synicPacketInfo = new Dictionary<string, SynicPacketInfomation>();

        //For LargePacket(UserId, (ch, value))
        Dictionary<string, Dictionary<byte, byte[]>> largeBuffer = new Dictionary<string,Dictionary<byte, byte[]>>();
        Dictionary<string, Dictionary<byte, LargePacketsInfomation>> largePacketInfo = new Dictionary<string, Dictionary<byte, LargePacketsInfomation>>();

        //Ref(for class)
        Dictionary<string, SynicSugar.Samples.ChatPlayer> ChatPlayer = new Dictionary<string, SynicSugar.Samples.ChatPlayer>();
        SynicSugar.Samples.Tank.TankGameManager TankGameManager;
        Dictionary<string, SynicSugar.Samples.Tank.TankPlayer> TankPlayer = new Dictionary<string, SynicSugar.Samples.Tank.TankPlayer>();
        Dictionary<string, SynicSugar.Samples.Tank.TankMovement> TankMovement = new Dictionary<string, SynicSugar.Samples.Tank.TankMovement>();
        Dictionary<string, SynicSugar.Samples.ReadHearts.Player> Player = new Dictionary<string, SynicSugar.Samples.ReadHearts.Player>();
        SynicSugar.Samples.ReadHearts.BattleSystem BattleSystem;
        SynicSugar.Samples.Tank.TankRoundTimer TankRoundTimer;

        //Clear ref
        private void ClearReferenceDictionaries(){ 
            ChatPlayer.Clear();
            TankGameManager = null;
            TankPlayer.Clear();
            TankMovement.Clear();
            Player.Clear();
            BattleSystem = null;
            TankRoundTimer = null;
            synicBuffer.Clear();
            synicPacketInfo.Clear();
            largeBuffer.Clear();
            largePacketInfo.Clear();
        }

        //Register(for class)
        public void RegisterInstance(UserId id, SynicSugar.Samples.ChatPlayer classInstance) {
            if (ChatPlayer.ContainsKey(id.ToString())) {
                ChatPlayer[id.ToString()] = classInstance;
            }else{
                ChatPlayer.Add(id.ToString(), classInstance);
            }
        }
        public void RegisterInstance(SynicSugar.Samples.Tank.TankGameManager classInstance) {
            TankGameManager = classInstance;
        }
        public void RegisterInstance(UserId id, SynicSugar.Samples.Tank.TankPlayer classInstance) {
            if (TankPlayer.ContainsKey(id.ToString())) {
                TankPlayer[id.ToString()] = classInstance;
            }else{
                TankPlayer.Add(id.ToString(), classInstance);
            }
        }
        public void RegisterInstance(UserId id, SynicSugar.Samples.Tank.TankMovement classInstance) {
            if (TankMovement.ContainsKey(id.ToString())) {
                TankMovement[id.ToString()] = classInstance;
            }else{
                TankMovement.Add(id.ToString(), classInstance);
            }
        }
        public void RegisterInstance(UserId id, SynicSugar.Samples.ReadHearts.Player classInstance) {
            if (Player.ContainsKey(id.ToString())) {
                Player[id.ToString()] = classInstance;
            }else{
                Player.Add(id.ToString(), classInstance);
            }
        }
        public void RegisterInstance(SynicSugar.Samples.ReadHearts.BattleSystem classInstance) {
            BattleSystem = classInstance;
        }
        public void RegisterInstance(SynicSugar.Samples.Tank.TankRoundTimer classInstance) {
            TankRoundTimer = classInstance;
        }
        
        /// <summary>
        /// Get the NetworkPlayer instance registered with ConnectHub.
        /// </summary>
        /// <param name="id">UserID to get</param>
        /// <returns>T's instance</returns>
        public T GetUserInstance<T>(UserId id) where T : IGetPlayer {
            if(typeof(T) == typeof(SynicSugar.Samples.ChatPlayer)){
                if (!ChatPlayer.ContainsKey(id.ToString())) {
                    return default(T);
                }
                return (T)(object)ChatPlayer[id.ToString()];
            }
            if(typeof(T) == typeof(SynicSugar.Samples.Tank.TankPlayer)){
                if (!TankPlayer.ContainsKey(id.ToString())) {
                    return default(T);
                }
                return (T)(object)TankPlayer[id.ToString()];
            }
            if(typeof(T) == typeof(SynicSugar.Samples.ReadHearts.Player)){
                if (!Player.ContainsKey(id.ToString())) {
                    return default(T);
                }
                return (T)(object)Player[id.ToString()];
            }
            return default(T);
        }
        
        /// <summary>
        /// Get the NetworkCommons instance registered with ConnectHub.
        /// </summary>
        /// <returns>T's instance</returns>
        public T GetInstance<T>() where T : IGetCommons {
            if(typeof(T) == typeof(SynicSugar.Samples.Tank.TankGameManager)){
                return (T)(object)TankGameManager;
            }
            if(typeof(T) == typeof(SynicSugar.Samples.ReadHearts.BattleSystem)){
                return (T)(object)BattleSystem;
            }
            if(typeof(T) == typeof(SynicSugar.Samples.Tank.TankRoundTimer)){
                return (T)(object)TankRoundTimer;
            }
            return default(T);
        }

        /// <summary>
        /// Remote RPC is invoked with received value.
        /// </summary>
        void IPacketConvert.ConvertFromPacket(ref byte ch, string id, ref ArraySegment<byte> payload){
            switch((Channels)ch){
                case Channels.UpdateChatText:
                    ChatPlayer[id].UpdateChatText(MemoryPackSerializer.Deserialize<string>(payload));
                return;
                case Channels.UpdateName:
                    ChatPlayer[id].UpdateName(MemoryPackSerializer.Deserialize<string>(payload));
                return;
                case Channels.SendLargePacketViaRpc:{
                    if(!RestoreLargePackets(ref ch, id, ref payload)){
                #if SYNICSUGAR_LOG 
                        Debug.LogFormat("ConvertFormPacket: Restore Large packet is in progress. for {0}", ch);
                #endif
                        return;
                    }
                    using var decompressorSendLargePacketViaRpc = new BrotliDecompressor();
                    Span<byte> SendLargePacketViaRpcPaylaod = new Span<byte>(largeBuffer[id][ch]);

                    var decompressedSendLargePacketViaRpc = decompressorSendLargePacketViaRpc.Decompress(SendLargePacketViaRpcPaylaod.Slice(0, largePacketInfo[id][ch].currentSize));
                
                    ChatPlayer[id].SendLargePacketViaRpc(MemoryPackSerializer.Deserialize<byte[]>(decompressedSendLargePacketViaRpc));
                
                    largeBuffer[id].Remove(ch);
                    largePacketInfo[id].Remove(ch);
                return; }
                case Channels.SetPlayerStatus:
                    TankPlayer[id].SetPlayerStatus(MemoryPackSerializer.Deserialize<SynicSugar.Samples.Tank.TankPlayerStatus>(payload));
                return;
                case Channels.SetDataAfterReconnect:
                    TankPlayer[id].SetDataAfterReconnect();
                return;
                case Channels.Ready:
                    TankPlayer[id].Ready();
                return;
                case Channels.Move:
                    TankPlayer[id].Move(MemoryPackSerializer.Deserialize<SynicSugar.Samples.Tank.TankMoveData>(payload));
                return;
                case Channels.Turn:
                    TankPlayer[id].Turn(MemoryPackSerializer.Deserialize<SynicSugar.Samples.Tank.TankMoveData>(payload));
                return;
                case Channels.Stop:
                    TankPlayer[id].Stop();
                return;
                case Channels.StartCharge:
                    TankPlayer[id].StartCharge();
                return;
                case Channels.Fire:
                    TankPlayer[id].Fire(MemoryPackSerializer.Deserialize<SynicSugar.Samples.Tank.TankShootingData>(payload));
                return;
                case Channels.TakeDamage:
                    TankPlayer[id].TakeDamage(MemoryPackSerializer.Deserialize<SynicSugar.Samples.Tank.TankDamageData>(payload));
                return;
                case Channels.correctedPlayerPosition:
                    MemoryPackSerializer.Deserialize<UnityEngine.Vector3>(payload, ref TankMovement[id].correctedPlayerPosition);
                return;
                case Channels.correctedPlayerQuaternion:
                    MemoryPackSerializer.Deserialize<UnityEngine.Quaternion>(payload, ref TankMovement[id].correctedPlayerQuaternion);
                return;
                case Channels.ReflectDamage:
                    Player[id].ReflectDamage(UserId.GetUserId(id), MemoryPackSerializer.Deserialize<int>(payload));
                return; 
                case Channels.UpdateChat:
                    Player[id].UpdateChat(UserId.GetUserId(id), MemoryPackSerializer.Deserialize<SynicSugar.Samples.ReadHearts.ChatContent>(payload));
                return; 
                case Channels.StartNewGame:
                    BattleSystem.isLocalCall = false;
                    BattleSystem.StartNewGame();
                return;
                case Channels.currentTime:
                    BattleSystem.isLocalCall = false;
                    BattleSystem.SetLocalcurrentTime(MemoryPackSerializer.Deserialize<float>(payload));
                    BattleSystem.isLocalCall = true;
                return;
                case Channels.SetTimestamp:
                    TankRoundTimer.isLocalCall = false;
                    TankRoundTimer.SetTimestamp(MemoryPackSerializer.Deserialize<uint>(payload));
                return;
                case Channels.StopTimer:
                    TankRoundTimer.isLocalCall = false;
                    TankRoundTimer.StopTimer();
                return;
                case Channels.ObtainPing:
                    EOSp2p.SendPacket((byte)Channels.ReturnPong, payload, UserId.GetUserId(id));
                return;
                case Channels.ReturnPong:
                    NetworkCore.GetPong(id, payload);
                return;
                case Channels.Synic:
                    string userId = id;
                    bool restoredPacket = RestoreSynicPackets(ref ch, ref userId, ref payload);
                    if(!restoredPacket){
    #if SYNICSUGAR_LOG 
                        Debug.LogFormat("ConvertFormPacket: Restore packet is in progress for {0} from {1}.", userId, id);
    #endif
                        return;
                    }
                    
                    OverwrittenSynicWithRemoteData(userId);

                    NetworkCore.UpdateSynicStatus(userId, synicPacketInfo[userId].phase);

                    //Init
                    synicBuffer.Remove(userId);
                    synicPacketInfo.Remove(userId);

                    //Stop overwriting localuser data with host data.
                    if(p2pInfo.Instance.IsLoaclUser(userId)){
                        NetworkCore.StopOverwritingLocalUserData();
                    }
                #if SYNICSUGAR_LOG 
                    Debug.LogFormat("ConvertFormPacket: Success overwriting {0}'s data by {1}"!, userId, id);
                #endif
                return;           
            }
        }

        /// <summary>
        /// Re-Send RPC with last recorded information.<br />
        /// To send disconnected peers after some time. SynicSugar retransmit to connecting-peers.<br />
        /// To record, pass true to attribute.
        /// </summary>
        public void ResendLastRPC(){
            if(p2pInfo.Instance.LastRPCIsLargePacket){
                EOSp2p.SendLargePacketsToAll(p2pInfo.Instance.LastRPCch, p2pInfo.Instance.LastRPCPayload).Forget();
                return;
            }
            EOSp2p.SendPacketToAll(p2pInfo.Instance.LastRPCch, p2pInfo.Instance.LastRPCPayload).Forget();
        }
        /// <summary>
        /// Re-Send RPC to the specific target with last recorded information.<br />
        /// In order to send disconnected peers after the some time. SynicSugar has retransmission to connecting-peers for the reliability.<br />
        /// To record, pass true to attribute.
        /// </summary>
        /// <param name="target"></param>
        public void ResendLastRPCToTarget(UserId target){
            if(p2pInfo.Instance.LastRPCIsLargePacket){
                EOSp2p.SendLargePackets(p2pInfo.Instance.LastRPCch, p2pInfo.Instance.LastRPCPayload, target).Forget();
                return;
            }
            EOSp2p.SendPacket(p2pInfo.Instance.LastRPCch, p2pInfo.Instance.LastRPCPayload, target);
        }
        /// <summary>
        /// Re-Send TargetRPC with last recorded information.<br />
        /// In order to send disconnected peers after the some time. SynicSugar has retransmission to connecting-peers for the reliability.<br />
        /// To record, pass true to attribute.
        /// </summary>
        public void ResendLastTargetRPC(){
            if(p2pInfo.Instance.LastTargetRPCIsLargePacket){
                EOSp2p.SendLargePackets(p2pInfo.Instance.LastTargetRPCch, p2pInfo.Instance.LastTargetRPCPayload, p2pInfo.Instance.LastTargetRPCUserId).Forget();
                return;
            }
            EOSp2p.SendPacket(p2pInfo.Instance.LastTargetRPCch, p2pInfo.Instance.LastTargetRPCPayload, p2pInfo.Instance.LastTargetRPCUserId);
        }

                
        /// <summary>
        /// Sync all Synic variables. This is very heavy because it handles multiple data and repeats compression and serialization.
        /// </summary>
        /// <param name="targetId">Target to be synced by this local user.</param>
        /// /// <param name="type">Whose data Host sends in Host's local. When set WithTarget or WithOthers, can overwrite the target's local data in Host's local data.</param>
        /// <param name="syncedPhase">Phase to be synced. If syncSinglePhase is false, sync all variables in the phase up to this point.</param>
        /// <param name="syncSinglePhase">If true, send only variables in syncedPhase.</param>
        public async void SyncSynic(UserId targetId, SynicType type, byte syncedPhase = 9, bool syncSinglePhase = false){
            //Sync local data to target local
            SynicContainer synicContainer = GenerateSynicContainer(p2pInfo.Instance.LocalUserId.ToString(), syncedPhase, syncSinglePhase);

            using var selfCompressor  = new BrotliCompressor();
            MemoryPackSerializer.Serialize(selfCompressor, synicContainer);

            EOSp2p.SendSynicPackets((byte)Channels.Synic, selfCompressor.ToArray(), targetId, p2pInfo.Instance.LocalUserId, syncedPhase, syncSinglePhase);

            if(type == SynicType.OnlySelf || !p2pInfo.Instance.IsHost()){
                return;
            }
            
            if(type == SynicType.WithOthers){
                foreach(var id in p2pInfo.Instance.DisconnectedUserIds){
                    synicContainer = GenerateSynicContainer(id.ToString(), syncedPhase, syncSinglePhase);

                    using var targetCompressor  = new BrotliCompressor();
                    MemoryPackSerializer.Serialize(targetCompressor, synicContainer);

                    EOSp2p.SendSynicPackets((byte)Channels.Synic, targetCompressor.ToArray(), targetId, id, syncedPhase, syncSinglePhase);
                    await UniTask.Yield();
                }
            }
            
            //Sync target data in local to target local
            synicContainer = GenerateSynicContainer(targetId.ToString(), syncedPhase, syncSinglePhase);

            using var reconnecterCompressor  = new BrotliCompressor();
            MemoryPackSerializer.Serialize(reconnecterCompressor, synicContainer);

            EOSp2p.SendSynicPackets((byte)Channels.Synic, reconnecterCompressor.ToArray(), targetId, targetId, syncedPhase, syncSinglePhase);
        }
        
        SynicContainer GenerateSynicContainer(string id, byte syncedPhase, bool syncSinglePhase){
            SynicContainer synicContainer = new SynicContainer();
            switch(syncedPhase){
                case 0: 
                    SynicItem0 synicItem0 = p2pInfo.Instance.IsHost(id) ? new SynicItem0(){ Name = ChatPlayer.ContainsKey(id) ? ChatPlayer[id]?.Name ?? default : default, submitCount = ChatPlayer.ContainsKey(id) ? ChatPlayer[id]?.submitCount ?? default : default, status = TankPlayer.ContainsKey(id) ? TankPlayer[id]?.status ?? default : default, CurrentGameState = TankGameManager != null ? TankGameManager?.CurrentGameState ?? default : default, startTimestamp = TankRoundTimer != null ? TankRoundTimer?.startTimestamp ?? default : default,} : new SynicItem0(){ Name = ChatPlayer.ContainsKey(id) ? ChatPlayer[id]?.Name ?? default : default, submitCount = ChatPlayer.ContainsKey(id) ? ChatPlayer[id]?.submitCount ?? default : default, status = TankPlayer.ContainsKey(id) ? TankPlayer[id]?.status ?? default : default,};
                    synicContainer.SynicItem0 = JsonUtility.ToJson(synicItem0);
                break;
                case 1: 
                    SynicItem1 synicItem1 = p2pInfo.Instance.IsHost(id) ? new SynicItem1(){ LargePacket = ChatPlayer.ContainsKey(id) ? ChatPlayer[id]?.LargePacket ?? default : default,} : new SynicItem1(){ LargePacket = ChatPlayer.ContainsKey(id) ? ChatPlayer[id]?.LargePacket ?? default : default,};
                    synicContainer.SynicItem1 = JsonUtility.ToJson(synicItem1);
                if (syncSinglePhase) { break; }
                else { goto case 0; }
                case 2: 
                if (syncSinglePhase) { break; }
                else { goto case 1; }
                case 3: 
                if (syncSinglePhase) { break; }
                else { goto case 2; }
                case 4: 
                if (syncSinglePhase) { break; }
                else { goto case 3; }
                case 5: 
                if (syncSinglePhase) { break; }
                else { goto case 4; }
                case 6: 
                if (syncSinglePhase) { break; }
                else { goto case 5; }
                case 7: 
                if (syncSinglePhase) { break; }
                else { goto case 6; }
                case 8: 
                if (syncSinglePhase) { break; }
                else { goto case 7; }
                case 9: 
                if (syncSinglePhase) { break; }
                else { goto case 8; }
                default:
                goto case 9;
            }
            return synicContainer;
        }
                
        //Synced 0 = index, 1 = additional packet amount
        bool RestoreLargePackets(ref byte ch, string id, ref ArraySegment<byte> payload){
            //Prep
            if(!largeBuffer.ContainsKey(id)){
                largePacketInfo.Add(id, new Dictionary<byte, LargePacketsInfomation>());
                largeBuffer.Add(id, new Dictionary<byte, byte[]>());
            }
            if(!largeBuffer[id].ContainsKey(ch)){
                largePacketInfo[id].Add(ch, new LargePacketsInfomation(){ additionalPacketsAmount = payload[1] });
                //Prep enough byte[]
                largeBuffer[id].Add(ch, new byte[(payload[1] + 1) * EOSp2p.MAX_LARGEPACKET_PAYLOADSIZE]);
            }

            int packetIndex = payload[0];
            int offset = packetIndex * EOSp2p.MAX_LARGEPACKET_PAYLOADSIZE;

    #if SYNICSUGAR_PACKETINFO
            Debug.Log($"RestoreLargePackets: ch {ch}({(Channels)ch}) from {id} / packet index {payload[0]}/{payload[1]}");
    #endif
            //Remove header
            Span<byte> packetPayload = payload.Slice(2);
            largePacketInfo[id][ch].currentSize += packetPayload.Length;
            //Copy Byte from what come in
            Buffer.BlockCopy(packetPayload.ToArray(), 0, largeBuffer[id][ch], offset, packetPayload.Length);

            //Comming all?
            //We don't know real packet size. So we need + 1166.
            //This first conditon for empty packet.
            return largePacketInfo[id][ch].additionalPacketsAmount == 0 || largePacketInfo[id][ch].currentSize + EOSp2p.MAX_LARGEPACKET_PAYLOADSIZE > largeBuffer[id][ch].Length ? true : false;
        }

        // 0-packet index, 1-additional packet amount, 2-complex data[1bit-isOnly, 4bits-phase, 3bits userType], 3-data's user index
        bool RestoreSynicPackets(ref byte ch, ref string id, ref ArraySegment<byte> payload){
            //Set target id
            int userDataType = (int)(payload[2] & 0x07);
            if(userDataType == 0){
                if(p2pInfo.Instance.IsHost(id) && p2pInfo.Instance.IsReconnecter){
                    id = p2pInfo.Instance.LocalUserId.ToString();
                }else{
                    return false;
                }
            }else if(userDataType == 2){
                if(p2pInfo.Instance.IsHost(id) && p2pInfo.Instance.IsReconnecter){
                    id = p2pInfo.Instance.AllUserIds[payload[3]].ToString();
                }else{
                    return false;
                }
            }

            if(!synicBuffer.ContainsKey(id)){
                synicPacketInfo.Add(id, new SynicPacketInfomation(){  basis = new (){ additionalPacketsAmount = payload[1]}, 
                                                                            phase = (byte)((payload[2] >> 3) & 0x0F), 
                                                                            isSinglePhase = (payload[2] & 0x80) != 0 });
                //Prep enough byte[]
                synicBuffer.Add(id, new byte[(payload[1] + 1) * EOSp2p.MAX_LARGEPACKET_PAYLOADSIZE]);
            }
            int packetIndex = payload[0];
            int offset = packetIndex * EOSp2p.MAX_LARGEPACKET_PAYLOADSIZE;

    #if SYNICSUGAR_PACKETINFO
            Debug.Log($"RestoreSynicPacket(Synic): ch {ch}({(Channels)ch}) / Data's userID {id} / packet index {payload[0]}/{payload[1]}");
    #endif
            //Remove header
            Span<byte> packetPayload = payload.Slice(4);
            synicPacketInfo[id].basis.currentSize += packetPayload.Length;
            //Copy Byte from what come in
            Buffer.BlockCopy(packetPayload.ToArray(), 0, synicBuffer[id], offset, packetPayload.Length);
            //Comming all?
            //We don't know real packet size. So we need + 1166.
            //This first conditon for empty packet.
            return synicPacketInfo[id].basis.additionalPacketsAmount == 0 || synicPacketInfo[id].basis.currentSize + EOSp2p.MAX_LARGEPACKET_PAYLOADSIZE > synicBuffer[id].Length ? true : false;
        }

        /// <summary>
        /// Call from ConvertFormPacket.
        /// </summary>
        void OverwrittenSynicWithRemoteData(string overwriterUserId){
            //Deserialize packet
            using var decompressor = new BrotliDecompressor();
            Span<byte> transmittedPaylaod = new Span<byte>(synicBuffer[overwriterUserId]);

            var decompressedBuffer = decompressor.Decompress(transmittedPaylaod.Slice(0, synicPacketInfo[overwriterUserId].basis.currentSize));
            SynicContainer container = MemoryPackSerializer.Deserialize<SynicContainer>(decompressedBuffer);

            //Packet data
            int phase = synicPacketInfo[overwriterUserId].phase;
            bool syncSinglePhase = synicPacketInfo[overwriterUserId].isSinglePhase;

            switch(phase){
                case 0:
                    if(container.SynicItem0 != null){
                        SynicItem0 synicItem0 = JsonUtility.FromJson<SynicItem0>(container.SynicItem0);
                        SyncedItem0(overwriterUserId, synicItem0);
                    }
                break;
                case 1:
                    if(container.SynicItem1 != null){
                        SynicItem1 synicItem1 = JsonUtility.FromJson<SynicItem1>(container.SynicItem1);
                        SyncedItem1(overwriterUserId, synicItem1);
                    }
                if (syncSinglePhase) { break; }
                else { goto case 0; }
                case 2:
                    if(container.SynicItem2 != null){
                        SynicItem2 synicItem2 = JsonUtility.FromJson<SynicItem2>(container.SynicItem2);
                        SyncedItem2(overwriterUserId, synicItem2);
                    }
                if (syncSinglePhase) { break; }
                else { goto case 1; }
                case 3:
                    if(container.SynicItem3 != null){
                        SynicItem3 synicItem3 = JsonUtility.FromJson<SynicItem3>(container.SynicItem3);
                        SyncedItem3(overwriterUserId, synicItem3);
                    }
                if (syncSinglePhase) { break; }
                else { goto case 2; }
                case 4:
                    if(container.SynicItem4 != null){
                        SynicItem4 synicItem4 = JsonUtility.FromJson<SynicItem4>(container.SynicItem4);
                        SyncedItem4(overwriterUserId, synicItem4);
                    }
                if (syncSinglePhase) { break; }
                else { goto case 3; }
                case 5:
                    if(container.SynicItem5 != null){
                        SynicItem5 synicItem5 = JsonUtility.FromJson<SynicItem5>(container.SynicItem5);
                        SyncedItem5(overwriterUserId, synicItem5);
                    }
                if (syncSinglePhase) { break; }
                else { goto case 4; }
                case 6:
                    if(container.SynicItem6 != null){
                        SynicItem6 synicItem6 = JsonUtility.FromJson<SynicItem6>(container.SynicItem6);
                        SyncedItem6(overwriterUserId, synicItem6);
                    }
                if (syncSinglePhase) { break; }
                else { goto case 5; }
                case 7:
                    if(container.SynicItem7 != null){
                        SynicItem7 synicItem7 = JsonUtility.FromJson<SynicItem7>(container.SynicItem7);
                        SyncedItem7(overwriterUserId, synicItem7);
                    }
                if (syncSinglePhase) { break; }
                else { goto case 6; }
                case 8:
                    if(container.SynicItem8 != null){
                        SynicItem8 synicItem8 = JsonUtility.FromJson<SynicItem8>(container.SynicItem8);
                        SyncedItem8(overwriterUserId, synicItem8);
                    }
                if (syncSinglePhase) { break; }
                else { goto case 7; }
                case 9:
                    if(container.SynicItem9 != null){
                        SynicItem9 synicItem9 = JsonUtility.FromJson<SynicItem9>(container.SynicItem9);
                        SyncedItem9(overwriterUserId, synicItem9);
                    }
                if (syncSinglePhase) { break; }
                else { goto case 8; }
                default:
                goto case 9;
            }
        }
        
        void SyncedItem0(string id, SynicItem0 synicItem){
            #if SYNICSUGAR_LOG
                string items = string.Empty;
                int itemCount = 0;
            #endif
            //Player
            
            if(ChatPlayer.ContainsKey(id)) {
            #if SYNICSUGAR_LOG
                items += "ChatPlayer.Name, ";
                itemCount++;
            #endif
                ChatPlayer[id].Name = synicItem.Name; 
            }
            if(ChatPlayer.ContainsKey(id)) {
            #if SYNICSUGAR_LOG
                items += "ChatPlayer.submitCount, ";
                itemCount++;
            #endif
                ChatPlayer[id].submitCount = synicItem.submitCount; 
            }
            if(TankPlayer.ContainsKey(id)) {
            #if SYNICSUGAR_LOG
                items += "TankPlayer.status, ";
                itemCount++;
            #endif
                TankPlayer[id].status = synicItem.status; 
            }
            if(p2pInfo.Instance.IsHost(id)){
                //Commons
                
                if(TankGameManager != null) {
            #if SYNICSUGAR_LOG
                    items += "TankGameManager.CurrentGameState, ";
                    itemCount++;
            #endif
                    TankGameManager.CurrentGameState = synicItem.CurrentGameState; 
            }
                if(TankRoundTimer != null) {
            #if SYNICSUGAR_LOG
                    items += "TankRoundTimer.startTimestamp, ";
                    itemCount++;
            #endif
                    TankRoundTimer.startTimestamp = synicItem.startTimestamp; 
            }
            }
        #if SYNICSUGAR_LOG
            if(itemCount > 0){
                Debug.Log($"SyncedItem0: {itemCount} Synics is overwritten by {id}. The List: ({items}) ");
            }
        #endif
        }
        void SyncedItem1(string id, SynicItem1 synicItem){
            #if SYNICSUGAR_LOG
                string items = string.Empty;
                int itemCount = 0;
            #endif
            //Player
            
            if(ChatPlayer.ContainsKey(id)) {
            #if SYNICSUGAR_LOG
                items += "ChatPlayer.LargePacket, ";
                itemCount++;
            #endif
                ChatPlayer[id].LargePacket = synicItem.LargePacket; 
            }
            if(p2pInfo.Instance.IsHost(id)){
                //Commons
                
            }
        #if SYNICSUGAR_LOG
            if(itemCount > 0){
                Debug.Log($"SyncedItem1: {itemCount} Synics is overwritten by {id}. The List: ({items}) ");
            }
        #endif
        }
        void SyncedItem2(string id, SynicItem2 synicItem){
            #if SYNICSUGAR_LOG
                string items = string.Empty;
                int itemCount = 0;
            #endif
            //Player
            
            if(p2pInfo.Instance.IsHost(id)){
                //Commons
                
            }
        #if SYNICSUGAR_LOG
            if(itemCount > 0){
                Debug.Log($"SyncedItem2: {itemCount} Synics is overwritten by {id}. The List: ({items}) ");
            }
        #endif
        }
        void SyncedItem3(string id, SynicItem3 synicItem){
            #if SYNICSUGAR_LOG
                string items = string.Empty;
                int itemCount = 0;
            #endif
            //Player
            
            if(p2pInfo.Instance.IsHost(id)){
                //Commons
                
            }
        #if SYNICSUGAR_LOG
            if(itemCount > 0){
                Debug.Log($"SyncedItem3: {itemCount} Synics is overwritten by {id}. The List: ({items}) ");
            }
        #endif
        }
        void SyncedItem4(string id, SynicItem4 synicItem){
            #if SYNICSUGAR_LOG
                string items = string.Empty;
                int itemCount = 0;
            #endif
            //Player
            
            if(p2pInfo.Instance.IsHost(id)){
                //Commons
                
            }
        #if SYNICSUGAR_LOG
            if(itemCount > 0){
                Debug.Log($"SyncedItem4: {itemCount} Synics is overwritten by {id}. The List: ({items}) ");
            }
        #endif
        }
        void SyncedItem5(string id, SynicItem5 synicItem){
            #if SYNICSUGAR_LOG
                string items = string.Empty;
                int itemCount = 0;
            #endif
            //Player
            
            if(p2pInfo.Instance.IsHost(id)){
                //Commons
                
            }
        #if SYNICSUGAR_LOG
            if(itemCount > 0){
                Debug.Log($"SyncedItem5: {itemCount} Synics is overwritten by {id}. The List: ({items}) ");
            }
        #endif
        }
        void SyncedItem6(string id, SynicItem6 synicItem){
            #if SYNICSUGAR_LOG
                string items = string.Empty;
                int itemCount = 0;
            #endif
            //Player
            
            if(p2pInfo.Instance.IsHost(id)){
                //Commons
                
            }
        #if SYNICSUGAR_LOG
            if(itemCount > 0){
                Debug.Log($"SyncedItem6: {itemCount} Synics is overwritten by {id}. The List: ({items}) ");
            }
        #endif
        }
        void SyncedItem7(string id, SynicItem7 synicItem){
            #if SYNICSUGAR_LOG
                string items = string.Empty;
                int itemCount = 0;
            #endif
            //Player
            
            if(p2pInfo.Instance.IsHost(id)){
                //Commons
                
            }
        #if SYNICSUGAR_LOG
            if(itemCount > 0){
                Debug.Log($"SyncedItem7: {itemCount} Synics is overwritten by {id}. The List: ({items}) ");
            }
        #endif
        }
        void SyncedItem8(string id, SynicItem8 synicItem){
            #if SYNICSUGAR_LOG
                string items = string.Empty;
                int itemCount = 0;
            #endif
            //Player
            
            if(p2pInfo.Instance.IsHost(id)){
                //Commons
                
            }
        #if SYNICSUGAR_LOG
            if(itemCount > 0){
                Debug.Log($"SyncedItem8: {itemCount} Synics is overwritten by {id}. The List: ({items}) ");
            }
        #endif
        }
        void SyncedItem9(string id, SynicItem9 synicItem){
            #if SYNICSUGAR_LOG
                string items = string.Empty;
                int itemCount = 0;
            #endif
            //Player
            
            if(p2pInfo.Instance.IsHost(id)){
                //Commons
                
            }
        #if SYNICSUGAR_LOG
            if(itemCount > 0){
                Debug.Log($"SyncedItem9: {itemCount} Synics is overwritten by {id}. The List: ({items}) ");
            }
        #endif
        }
    }
}