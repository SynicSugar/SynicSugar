//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace SynicSugarGenerator {
    using System.Linq;
    using System.Text;
    using System.Collections.Generic;
    using Microsoft.CodeAnalysis.CSharp.Syntax;
    using System;
    
    
    public partial class ConnecthubTemplate : ConnecthubTemplateBase {
        
        public virtual string TransformText() {
            this.GenerationEnvironment = null;
            
            #line 9 ""
            this.Write("// <auto-generated>\n// THIS (.cs) FILE IS GENERATED BY SynicSugarGenerator. DO NO" +
                    "T CHANGE IT.\n// </auto-generated>\n#pragma warning disable CS0164 // This label h" +
                    "as not been referenced\n#pragma warning disable CS0436 // Type conflicts with the" +
                    " imported type\n\nusing UnityEngine;\nusing MemoryPack;\nusing MemoryPack.Compressio" +
                    "n;\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing" +
                    " Cysharp.Threading.Tasks;\nusing SynicSugar.RTC;\nnamespace SynicSugar.P2P {\n    i" +
                    "nternal sealed class ConnectHub {\n        //Singleton\n        private static Laz" +
                    "y<ConnectHub> instance = new Lazy<ConnectHub>();\n        public static ConnectHu" +
                    "b Instance => instance.Value;\n\n        public ConnectHub(){}\n        byte ch_r;\n" +
                    "        string id_r;\n        ArraySegment<byte> payload_r;\n        //Start\n     " +
                    "   /// <summary>\n        /// Start the packet receiver. Call after creating the " +
                    "Network Instance required for reception.<br />\n        /// This cannot be called" +
                    " with other Receiver same time. If start the other Receiver, ConenctHub stop thi" +
                    "s Receiver automatically before start the new one.\n        /// </summary>\n      " +
                    "  // Default Relay Setting is AllowRelay. To change this, get NatType.\n        p" +
                    "ublic void StartPacketReceiver(){\n            if(p2pConnectorForOtherAssembly.In" +
                    "stance.p2pToken != null && !p2pConnectorForOtherAssembly.Instance.p2pToken.IsCan" +
                    "cellationRequested){\n                p2pConnectorForOtherAssembly.Instance.p2pTo" +
                    "ken.Cancel();\n            }\n\n            p2pConnectorForOtherAssembly.Instance.p" +
                    "2pToken = new CancellationTokenSource();\n\n            if(p2pConfig.Instance.Auto" +
                    "RefreshPing){\n                p2pConnectorForOtherAssembly.Instance.AutoRefreshP" +
                    "ings(p2pConnectorForOtherAssembly.Instance.p2pToken.Token).Forget();\n           " +
                    " }\n\n            if(p2pConfig.Instance.getPacketFrequency == p2pConfig.GetPacketF" +
                    "requency.PerSecondBurstFPS){\n                ReciveMultiplePackets(p2pConnectorF" +
                    "orOtherAssembly.Instance.p2pToken.Token).Forget();\n            }else{\n          " +
                    "      RecivePacket(p2pConnectorForOtherAssembly.Instance.p2pToken.Token).Forget(" +
                    ");\n            }\n            if(p2pConnectorForOtherAssembly.Instance.IsEnableRT" +
                    "C){\n                RTCManager.Instance.ToggleReceiveingFromTarget(null, true);\n" +
                    "            }\n        }\n        \n        /// <summary>\n        /// To get only S" +
                    "ynicPacket in burst FPS. Call after creating the Network Instance required for r" +
                    "eception.<br />\n        /// This cannot be called with other Receiver same time." +
                    " If start the other Receiver, ConenctHub stop this Receiver automatically before" +
                    " start the new one.\n        /// </summary>\n        public void StartSynicReceive" +
                    "r(){\n            if(p2pConnectorForOtherAssembly.Instance.p2pToken != null && !p" +
                    "2pConnectorForOtherAssembly.Instance.p2pToken.IsCancellationRequested){\n        " +
                    "        p2pConnectorForOtherAssembly.Instance.p2pToken.Cancel();\n            }\n\n" +
                    "            p2pConnectorForOtherAssembly.Instance.p2pToken = new CancellationTok" +
                    "enSource();\n\n            ReciveSynicPackets(p2pConnectorForOtherAssembly.Instanc" +
                    "e.p2pToken.Token).Forget();\n        }\n        //Pause receiver\n        /// <summ" +
                    "ary>\n        /// Pause getting a packet from the buffer. To re-start, call Start" +
                    "PacketReceiver().<br />\n        /// *Packet receiving to the buffer is continue." +
                    " If the packet is over the buffer, subsequent packets are discarded.\n        ///" +
                    " </summary>\n        public void PausetPacketReceiver(){\n            if(p2pConnec" +
                    "torForOtherAssembly.Instance.p2pToken != null && !p2pConnectorForOtherAssembly.I" +
                    "nstance.p2pToken.IsCancellationRequested){\n                p2pConnectorForOtherA" +
                    "ssembly.Instance.p2pToken.Cancel();\n            }\n        }\n\n        //Pause Rec" +
                    "iving buffer\n        /// <summary>\n        /// Pause receiving a packet to the r" +
                    "eceive buffer. To re-start, call RestartConnections(). <br />\n        /// After " +
                    "call this, packets will have been discarded until connection will re-open.<br />" +
                    "\n        /// WARNING: This doesn\'t work as intended now. Can\'t stop receiving pa" +
                    "ckets to buffer, so SynicSugar discard those packets before re-start.\n        //" +
                    "/ </summary>\n        /// <param name=\"isForced\">If True, force to stop and clear" +
                    " current packet queue. <br />\n        /// If false, process current queue, then " +
                    "stop it.</param>\n        public async UniTask PauseConnections(bool isForced = f" +
                    "alse, CancellationTokenSource cancelToken = default(CancellationTokenSource)){\n " +
                    "           if(cancelToken == default(CancellationTokenSource)){\n                " +
                    "cancelToken = new CancellationTokenSource();\n            }\n            await p2p" +
                    "ConnectorForOtherAssembly.Instance.PauseConnections(isForced, cancelToken.Token)" +
                    ";\n        }\n        /// <summary>\n        /// Prepare to receive packets in adva" +
                    "nce. If user sent a packet, it can also open connection to get packets without t" +
                    "his.\n        /// </summary>\n        public void RestartConnections(){\n          " +
                    "  p2pConnectorForOtherAssembly.Instance.RestartConnections();\n            StartP" +
                    "acketReceiver();\n        }\n        \n        /// <summary>\n        /// Stop recei" +
                    "ver, close all connections and remove the notify events.\n        /// Then, the u" +
                    "ser leave the lobby.<br />\n        /// The last user closes the lobby in Backend" +
                    ".\n        /// </summary>\n        public async UniTask<bool> ExitSession(bool des" +
                    "troyManager = true, CancellationTokenSource cancelToken = default(CancellationTo" +
                    "kenSource)){\n            if(cancelToken == default(CancellationTokenSource)){\n  " +
                    "              cancelToken = new CancellationTokenSource();\n            }\n       " +
                    "     bool isSuccess = await p2pConnectorForOtherAssembly.Instance.ExitSession(de" +
                    "stroyManager, cancelToken.Token);\n            ClearReferenceDictionaries();\n    " +
                    "        return isSuccess;\n        }\n        /// <summary>\n        /// Stop recei" +
                    "ver, close all connections and remove the notify events.\n        /// Then, Host " +
                    "closes and Guest leaves the Lobby.<br />\n        /// When Host closes Lobby, Gue" +
                    "sts are automatically kicked out from the Lobby.\n        /// </summary>\n        " +
                    "public async UniTask<bool> CloseSession(bool destroyManager = true, Cancellation" +
                    "TokenSource cancelToken = default(CancellationTokenSource)){\n            if(canc" +
                    "elToken == default(CancellationTokenSource)){\n                cancelToken = new " +
                    "CancellationTokenSource();\n            }\n            bool isSuccess = await p2pC" +
                    "onnectorForOtherAssembly.Instance.CloseSession(destroyManager, cancelToken.Token" +
                    ");\n            ClearReferenceDictionaries();\n            return isSuccess;\n     " +
                    "   }\n\n\n        async UniTask RecivePacket(CancellationToken token){\n            " +
                    "while(!token.IsCancellationRequested){\n                bool recivePacket = p2pCo" +
                    "nnectorForOtherAssembly.Instance.GetPacketFromBuffer(ref ch_r, ref id_r, ref pay" +
                    "load_r);\n\n                if(recivePacket){\n                    ConvertFromPacke" +
                    "t(ref ch_r, ref id_r, ref payload_r);\n                }\n                await Un" +
                    "iTask.Delay(p2pConnectorForOtherAssembly.Instance.receiverInterval, cancellation" +
                    "Token: token);\n\n                if(p2pConnectorForOtherAssembly.Instance == null" +
                    "){\n                    break;\n                }\n            }\n        }\n        " +
                    "async UniTask ReciveMultiplePackets(CancellationToken token){\n            int co" +
                    "unt = p2pConfig.Instance.BurstReceiveBatchSize;\n\n            while(!token.IsCanc" +
                    "ellationRequested){\n                bool recivePacket = p2pConnectorForOtherAsse" +
                    "mbly.Instance.GetPacketFromBuffer(ref ch_r, ref id_r, ref payload_r);\n          " +
                    "      count--;\n\n                if(recivePacket){\n                    ConvertFro" +
                    "mPacket(ref ch_r, ref id_r, ref payload_r);\n                }\n\n                i" +
                    "f(count == 0 || !recivePacket){\n                    await UniTask.Yield(PlayerLo" +
                    "opTiming.Update, cancellationToken : token);\n                    \n              " +
                    "      if(p2pConnectorForOtherAssembly.Instance == null){\n                       " +
                    " break;\n                    }\n                    count = p2pConfig.Instance.Bur" +
                    "stReceiveBatchSize;\n                }\n            }\n        }\n        async UniT" +
                    "ask ReciveSynicPackets(CancellationToken token){\n            int count = p2pConf" +
                    "ig.Instance.SynicReceiverBatchSize;\n\n            while(!token.IsCancellationRequ" +
                    "ested){\n                bool recivePacket = p2pConnectorForOtherAssembly.Instanc" +
                    "e.GetSynicPacketFromBuffer(ref ch_r, ref id_r, ref payload_r);\n                c" +
                    "ount--;\n\n                if(recivePacket){\n                    ConvertFromPacket" +
                    "(ref ch_r, ref id_r, ref payload_r);\n                }\n\n                if(count" +
                    " == 0 || !recivePacket){\n                    await UniTask.Yield(PlayerLoopTimin" +
                    "g.Update, cancellationToken : token);\n                    \n                    i" +
                    "f(p2pConnectorForOtherAssembly.Instance == null){\n                        break;" +
                    "\n                    }\n                    count = p2pConfig.Instance.SynicRecei" +
                    "verBatchSize;\n                }\n            }\n        }\n\n        //(for elements" +
                    ")\n        public enum CHANNELLIST{\n            ");
            
            #line default
            #line hidden
            
            #line 193 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( SyncList ));
            
            #line default
            #line hidden
            
            #line 193 ""
            this.Write(@"
        }
        //For Synic(UserId, value)
        Dictionary<string, byte[]> synicBuffer = new Dictionary<string, byte[]>();
        Dictionary<string, SynicPacketInfomation> synicPacketInfo = new Dictionary<string, SynicPacketInfomation>();

        //For LargePacket(UserId, (ch, value))
        Dictionary<string, Dictionary<byte, byte[]>> largeBuffer = new Dictionary<string,Dictionary<byte, byte[]>>();
        Dictionary<string, Dictionary<byte, LargePacketsInfomation>> largePacketInfo = new Dictionary<string, Dictionary<byte, LargePacketsInfomation>>();

        //Ref(for class)");
            
            #line default
            #line hidden
            
            #line 203 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( Reference ));
            
            #line default
            #line hidden
            
            #line 203 ""
            this.Write("\n\n        //Clear ref\n        private void ClearReferenceDictionaries(){ ");
            
            #line default
            #line hidden
            
            #line 206 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( ClearReference ));
            
            #line default
            #line hidden
            
            #line 206 ""
            this.Write("\n            synicBuffer.Clear();\n            synicPacketInfo.Clear();\n          " +
                    "  largeBuffer.Clear();\n            largePacketInfo.Clear();\n        }\n\n        /" +
                    "/Register(for class)");
            
            #line default
            #line hidden
            
            #line 213 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( Register ));
            
            #line default
            #line hidden
            
            #line 213 ""
            this.Write(@"
        
        /// <summary>
        /// Get the NetworkPlayer instance registered with ConnectHub.
        /// </summary>
        /// <param name=""id"">UserID to get</param>
        /// <returns>T's instance</returns>
        public T GetUserInstance<T>(UserId id) where T : IGetPlayer {");
            
            #line default
            #line hidden
            
            #line 220 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( PlayeInstance ));
            
            #line default
            #line hidden
            
            #line 220 ""
            this.Write(@"
            return default(T);
        }
        
        /// <summary>
        /// Get the NetworkCommons instance registered with ConnectHub.
        /// </summary>
        /// <returns>T's instance</returns>
        public T GetInstance<T>() where T : IGetCommons {");
            
            #line default
            #line hidden
            
            #line 228 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( CommonsInstance ));
            
            #line default
            #line hidden
            
            #line 228 ""
            this.Write("\n            return default(T);\n        }\n\n        //SendPacket(for elements)\n   " +
                    "     public void ConvertFromPacket(ref byte ch, ref string id, ref ArraySegment<" +
                    "byte> payload){\n            switch((CHANNELLIST)ch){");
            
            #line default
            #line hidden
            
            #line 234 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( PacketConvert ));
            
            #line default
            #line hidden
            
            #line 234 ""
            this.Write("\n                case CHANNELLIST.ObtainPing:\n                    EOSp2p.SendPack" +
                    "et((byte)CHANNELLIST.ReturnPong, payload, UserId.GetUserId(id));\n               " +
                    " return;\n                case CHANNELLIST.ReturnPong:\n                    p2pCon" +
                    "nectorForOtherAssembly.Instance.GetPong(id, payload);\n                return;\n  " +
                    "              case CHANNELLIST.Synic:\n                    bool restoredPacket = " +
                    "RestoreSynicPackets(ref ch, ref id, ref payload);\n                    if(!restor" +
                    "edPacket){\n    #if SYNICSUGAR_LOG \n                        Debug.LogFormat(\"Conv" +
                    "ertFormPacket: Restore packet is in progress. for {0}\", id);\n    #endif\n        " +
                    "                return;\n                    }\n                    SyncedSynic(id" +
                    ");\n\n                    p2pConnectorForOtherAssembly.Instance.UpdateSyncedState(" +
                    "id, synicPacketInfo[id].phase);\n\n                    //Init\n                    " +
                    "synicBuffer.Remove(id);\n                    synicPacketInfo.Remove(id);\n\n       " +
                    "             //Change AcceptHostsSynic flag.\n                    if(p2pInfo.Inst" +
                    "ance.IsLoaclUser(id)){\n                        p2pConnectorForOtherAssembly.Inst" +
                    "ance.CloseHostSynic();\n                    }\n                    \n              " +
                    "  return;\n            }\n        }\n\n        /// <summary>\n        /// Re-Send RPC" +
                    " with last recorded information.<br />\n        /// To send disconnected peers af" +
                    "ter some time. SynicSugar retransmit to connecting-peers.<br />\n        /// To r" +
                    "ecord, pass true to attribute.\n        /// </summary>\n        public void Resend" +
                    "LastRPC(){\n            if(p2pInfo.Instance.LastRPCIsLargePacket){\n              " +
                    "  EOSp2p.SendLargePacketsToAll(p2pInfo.Instance.LastRPCch, p2pInfo.Instance.Last" +
                    "RPCPayload).Forget();\n                return;\n            }\n            EOSp2p.S" +
                    "endPacketToAll(p2pInfo.Instance.LastRPCch, p2pInfo.Instance.LastRPCPayload).Forg" +
                    "et();\n        }\n        /// <summary>\n        /// Re-Send RPC to the specific ta" +
                    "rget with last recorded information.<br />\n        /// In order to send disconne" +
                    "cted peers after the some time. SynicSugar has retransmission to connecting-peer" +
                    "s for the reliability.<br />\n        /// To record, pass true to attribute.\n    " +
                    "    /// </summary>\n        /// <param name=\"target\"></param>\n        public void" +
                    " ResendLastRPCToTarget(UserId target){\n            if(p2pInfo.Instance.LastRPCIs" +
                    "LargePacket){\n                EOSp2p.SendLargePackets(p2pInfo.Instance.LastRPCch" +
                    ", p2pInfo.Instance.LastRPCPayload, target).Forget();\n                return;\n   " +
                    "         }\n            EOSp2p.SendPacket(p2pInfo.Instance.LastRPCch, p2pInfo.Ins" +
                    "tance.LastRPCPayload, target);\n        }\n        /// <summary>\n        /// Re-Se" +
                    "nd TargetRPC with last recorded information.<br />\n        /// In order to send " +
                    "disconnected peers after the some time. SynicSugar has retransmission to connect" +
                    "ing-peers for the reliability.<br />\n        /// To record, pass true to attribu" +
                    "te.\n        /// </summary>\n        public void ResendLastTargetRPC(){\n          " +
                    "  if(p2pInfo.Instance.LastTargetRPCIsLargePacket){\n                EOSp2p.SendLa" +
                    "rgePackets(p2pInfo.Instance.LastTargetRPCch, p2pInfo.Instance.LastTargetRPCPaylo" +
                    "ad, p2pInfo.Instance.LastTargetRPCUserId).Forget();\n                return;\n    " +
                    "        }\n            EOSp2p.SendPacket(p2pInfo.Instance.LastTargetRPCch, p2pInf" +
                    "o.Instance.LastTargetRPCPayload, p2pInfo.Instance.LastTargetRPCUserId);\n        " +
                    "}\n\n        ");
            
            #line default
            #line hidden
            
            #line 304 ""
 if (needSyncSynic) { 
            
            #line default
            #line hidden
            
            #line 305 ""
            this.Write("        \n        /// <summary>\n        /// Sync all Synic variables. This is very" +
                    " heavy because it handles multiple data and repeats compression and serializatio" +
                    "n.\n        /// </summary>\n        /// <param name=\"targetId\">Target to be synced" +
                    " by this local user.</param>\n        /// /// <param name=\"type\">Whose data Host " +
                    "sends in Host\'s local. When set WithTarget or WithOthers, can overwrite the targ" +
                    "et\'s local data in Host\'s local data.</param>\n        /// <param name=\"syncedPha" +
                    "se\">Phase to be synced. If syncSinglePhase is false, sync all variables in the p" +
                    "hase up to this point.</param>\n        /// <param name=\"syncSinglePhase\">If true" +
                    ", send only variables in syncedPhase.</param>\n        public async void SyncSyni" +
                    "c(UserId targetId, SynicType type, byte syncedPhase = 9, bool syncSinglePhase = " +
                    "false){\n            //Sync local data to target local\n            SynicContainer" +
                    " synicContainer = GenerateSynicContainer(p2pInfo.Instance.LocalUserId, syncedPha" +
                    "se, syncSinglePhase);\n\n            using var selfCompressor  = new BrotliCompres" +
                    "sor();\n            MemoryPackSerializer.Serialize(selfCompressor, synicContainer" +
                    ");\n\n            EOSp2p.SendSynicPackets((byte)CHANNELLIST.Synic, selfCompressor." +
                    "ToArray(), targetId, p2pInfo.Instance.LocalUserId, syncedPhase, syncSinglePhase)" +
                    ";\n\n            if(type == SynicType.OnlySelf || !p2pInfo.Instance.IsHost()){\n   " +
                    "             return;\n            }\n            if(type == SynicType.WithOthers){" +
                    "\n                foreach(var id in p2pInfo.Instance.DisconnectedUserIds){\n      " +
                    "              synicContainer = GenerateSynicContainer(id, syncedPhase, syncSingl" +
                    "ePhase);\n\n                    using var targetCompressor  = new BrotliCompressor" +
                    "();\n                    MemoryPackSerializer.Serialize(targetCompressor, synicCo" +
                    "ntainer);\n\n                    EOSp2p.SendSynicPackets((byte)CHANNELLIST.Synic, " +
                    "targetCompressor.ToArray(), targetId, id, syncedPhase, syncSinglePhase);\n       " +
                    "             \n                    await UniTask.Yield();\n                }\n     " +
                    "       }\n            \n            //Sync target data in local to target local\n  " +
                    "          synicContainer = GenerateSynicContainer(targetId, syncedPhase, syncSin" +
                    "glePhase);\n\n            using var reconnecterCompressor  = new BrotliCompressor(" +
                    ");\n            MemoryPackSerializer.Serialize(reconnecterCompressor, synicContai" +
                    "ner);\n\n            EOSp2p.SendSynicPackets((byte)CHANNELLIST.Synic, reconnecterC" +
                    "ompressor.ToArray(), targetId, targetId, syncedPhase, syncSinglePhase);\n        " +
                    "}\n        \n        SynicContainer GenerateSynicContainer(UserId id, byte syncedP" +
                    "hase, bool syncSinglePhase){\n            SynicContainer synicContainer = new Syn" +
                    "icContainer();\n            switch(syncedPhase){");
            
            #line default
            #line hidden
            
            #line 349 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( GenerateSynicContainer ));
            
            #line default
            #line hidden
            
            #line 349 ""
            this.Write("\n                default:\n                goto case 9;\n            }\n            " +
                    "return synicContainer;\n        }\n        \n        #region Obsolete\n        [Obso" +
                    "lete(\"This is old. SyncSynic(UserId targetId, SynicType type, byte syncedPhase =" +
                    " 9, bool syncSinglePhase = false) is new one.\")]\n        /// <summary>\n        /" +
                    "// Sync all Synic variables. This is very heavy because it handles multiple data" +
                    " and repeats compression and serialization.\n        /// </summary>\n        /// <" +
                    "param name=\"targetId\">Target to be synced by this local user.</param>\n        //" +
                    "/ <param name=\"syncedPhase\">Phase to be synced. If syncSinglePhase is false, syn" +
                    "c all variables in the phase up to this point.</param>\n        /// <param name=\"" +
                    "syncSinglePhase\">If true, send only variables in syncedPhase.</param>\n        //" +
                    "/ <param name=\"syncTargetsData\">If true, sync target\'s data in Host local. When " +
                    "the target AllowHostsSynic, can overwrite the target\'s data in that local only o" +
                    "nce.</param>\n        public void SyncSynic(UserId targetId, byte syncedPhase = 9" +
                    ", bool syncSinglePhase = false, bool syncTargetsData = true){\n            //Sync" +
                    " local data to target local\n            SynicContainer synicContainer = Generate" +
                    "SynicContainer(p2pInfo.Instance.LocalUserId, syncedPhase, syncSinglePhase);\n\n   " +
                    "         using var selfCompressor  = new BrotliCompressor();\n            MemoryP" +
                    "ackSerializer.Serialize(selfCompressor, synicContainer);\n\n            EOSp2p.Sen" +
                    "dSynicPackets((byte)CHANNELLIST.Synic, selfCompressor.ToArray(), targetId, synce" +
                    "dPhase, syncSinglePhase);\n\n            if(!syncTargetsData || !p2pInfo.Instance." +
                    "IsHost()){\n                return;\n            }\n            //Sync target data " +
                    "in local to target local\n\n            synicContainer = GenerateSynicContainer(ta" +
                    "rgetId, syncedPhase, syncSinglePhase);\n\n            using var targetCompressor  " +
                    "= new BrotliCompressor();\n            MemoryPackSerializer.Serialize(targetCompr" +
                    "essor, synicContainer);\n\n            EOSp2p.SendSynicPackets((byte)CHANNELLIST.S" +
                    "ynic, targetCompressor.ToArray(), targetId, syncedPhase, syncSinglePhase, false)" +
                    ";\n        }\n        #endregion\n        ");
            
            #line default
            #line hidden
            
            #line 387 ""
 } 
            
            #line default
            #line hidden
            
            #line 388 ""
            this.Write("        \n        //Synced 0 = index, 1 = chunk\n        bool RestoreLargePackets(r" +
                    "ef byte ch, ref string id, ref ArraySegment<byte> payload){\n            //Prep\n " +
                    "           if(!largeBuffer.ContainsKey(id)){\n                largePacketInfo.Add" +
                    "(id, new Dictionary<byte, LargePacketsInfomation>());\n                largeBuffe" +
                    "r.Add(id, new Dictionary<byte, byte[]>());\n            }\n            if(!largeBu" +
                    "ffer[id].ContainsKey(ch)){\n                largePacketInfo[id].Add(ch, new Large" +
                    "PacketsInfomation(){ chunk = payload[1] });\n                //Prep enough byte[]" +
                    "\n                largeBuffer[id].Add(ch, new byte[payload[1] * 1160]);\n         " +
                    "   }\n\n            int packetIndex = payload[0];\n            int offset = packetI" +
                    "ndex * 1160;\n\n    #if SYNICSUGAR_LOG\n            Debug.Log($\"RestoreLargePackets" +
                    ": PacketInfo:: ch {ch} / index {payload[0]} / chunk {payload[1]}\");\n    #endif\n " +
                    "           //Remove header\n            Span<byte> packetPayload = payload.Slice(" +
                    "2);\n            largePacketInfo[id][ch].currentSize += packetPayload.Length;\n   " +
                    "         //Copy Byte from what come in\n            Buffer.BlockCopy(packetPayloa" +
                    "d.ToArray(), 0, largeBuffer[id][ch], offset, packetPayload.Length);\n\n           " +
                    " //Comming all?\n            return largePacketInfo[id][ch].currentSize + 1160 > " +
                    "largeBuffer[id][ch].Length ? true : false;\n        }\n\n        //Synced 0 = index" +
                    ", 1 = chunk, 2 = phase, 3 = syncSinglePhase, 4 = whose data?(0: localUser, 1: se" +
                    "nder, 2: other), 5 = targetIndex\n        bool RestoreSynicPackets(ref byte ch, r" +
                    "ef string id, ref ArraySegment<byte> payload){\n            //Set target id\n     " +
                    "       if(payload[4] == 0){\n                if(p2pInfo.Instance.IsHost(id) && p2" +
                    "pInfo.Instance.IsReconnecter){\n                    id = p2pInfo.Instance.LocalUs" +
                    "erId.ToString();\n                }else{\n                    return false;\n      " +
                    "          }\n            }else if(payload[4] == 2){\n                if(p2pInfo.In" +
                    "stance.IsHost(id) && p2pInfo.Instance.IsReconnecter){\n                    id = p" +
                    "2pInfo.Instance.AllUserIds[payload[5]].ToString();\n                }else{\n      " +
                    "              return false;\n                }\n            }\n\n\n            if(!sy" +
                    "nicBuffer.ContainsKey(id)){\n                synicPacketInfo.Add(id, new SynicPac" +
                    "ketInfomation(){  basis = new (){ chunk = payload[1]}, \n                        " +
                    "                                                    phase = payload[2], \n       " +
                    "                                                                     syncSingleP" +
                    "hase = payload[3] == 1 ? true : false });\n                //Prep enough byte[]\n " +
                    "               synicBuffer.Add(id, new byte[payload[1] * 1160]);\n            }\n " +
                    "           int packetIndex = payload[0];\n            int offset = packetIndex * " +
                    "1160;\n\n    #if SYNICSUGAR_LOG\n            Debug.Log($\"RestoreSynicPackets: Packe" +
                    "tInfo:: index {payload[0]} / chunk {payload[1]} / phase {payload[2]} / syncSingl" +
                    "ePhase {payload[3]}\");\n    #endif\n            //Remove header\n            Span<b" +
                    "yte> packetPayload = payload.Slice(6);\n            synicPacketInfo[id].basis.cur" +
                    "rentSize += packetPayload.Length;\n            //Copy Byte from what come in\n    " +
                    "        Buffer.BlockCopy(packetPayload.ToArray(), 0, synicBuffer[id], offset, pa" +
                    "cketPayload.Length);\n            //Comming all?\n            return synicPacketIn" +
                    "fo[id].basis.currentSize + 1160 > synicBuffer[id].Length ? true : false;\n       " +
                    " }\n\n        /// <summary>\n        /// Call from ConvertFormPacket.\n        /// <" +
                    "/summary>\n        void SyncedSynic(string overwriterUserId){\n            //Deser" +
                    "ialize packet\n            using var decompressor = new BrotliDecompressor();\n   " +
                    "         Span<byte> transmittedPaylaod = new Span<byte>(synicBuffer[overwriterUs" +
                    "erId]);\n\n            var decompressedBuffer = decompressor.Decompress(transmitte" +
                    "dPaylaod.Slice(0, synicPacketInfo[overwriterUserId].basis.currentSize));\n       " +
                    "     SynicContainer container = MemoryPackSerializer.Deserialize<SynicContainer>" +
                    "(decompressedBuffer);\n#if SYNICSUGAR_LOG\n            Debug.Log($\"SyncedSynic: De" +
                    "serialize is Success for {overwriterUserId}\");\n    #endif\n\n            //Packet " +
                    "data\n            int phase = synicPacketInfo[overwriterUserId].phase;\n          " +
                    "  bool syncSinglePhase = synicPacketInfo[overwriterUserId].syncSinglePhase;\n\n   " +
                    "         switch(phase){");
            
            #line default
            #line hidden
            
            #line 476 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( SyncedInvoker ));
            
            #line default
            #line hidden
            
            #line 476 ""
            this.Write("\n                default:\n                goto case 9;\n            }\n        }\n  " +
                    "      ");
            
            #line default
            #line hidden
            
            #line 481 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( SyncedItems ));
            
            #line default
            #line hidden
            
            #line 481 ""
            this.Write("\n    }\n}");
            
            #line default
            #line hidden
            return this.GenerationEnvironment.ToString();
        }
        
        public virtual void Initialize() {
        }
    }
    
    public class ConnecthubTemplateBase {
        
        private global::System.Text.StringBuilder builder;
        
        private global::System.Collections.Generic.IDictionary<string, object> session;
        
        private global::System.CodeDom.Compiler.CompilerErrorCollection errors;
        
        private string currentIndent = string.Empty;
        
        private global::System.Collections.Generic.Stack<int> indents;
        
        private ToStringInstanceHelper _toStringHelper = new ToStringInstanceHelper();
        
        public virtual global::System.Collections.Generic.IDictionary<string, object> Session {
            get {
                return this.session;
            }
            set {
                this.session = value;
            }
        }
        
        public global::System.Text.StringBuilder GenerationEnvironment {
            get {
                if ((this.builder == null)) {
                    this.builder = new global::System.Text.StringBuilder();
                }
                return this.builder;
            }
            set {
                this.builder = value;
            }
        }
        
        protected global::System.CodeDom.Compiler.CompilerErrorCollection Errors {
            get {
                if ((this.errors == null)) {
                    this.errors = new global::System.CodeDom.Compiler.CompilerErrorCollection();
                }
                return this.errors;
            }
        }
        
        public string CurrentIndent {
            get {
                return this.currentIndent;
            }
        }
        
        private global::System.Collections.Generic.Stack<int> Indents {
            get {
                if ((this.indents == null)) {
                    this.indents = new global::System.Collections.Generic.Stack<int>();
                }
                return this.indents;
            }
        }
        
        public ToStringInstanceHelper ToStringHelper {
            get {
                return this._toStringHelper;
            }
        }
        
        public void Error(string message) {
            this.Errors.Add(new global::System.CodeDom.Compiler.CompilerError(null, -1, -1, null, message));
        }
        
        public void Warning(string message) {
            global::System.CodeDom.Compiler.CompilerError val = new global::System.CodeDom.Compiler.CompilerError(null, -1, -1, null, message);
            val.IsWarning = true;
            this.Errors.Add(val);
        }
        
        public string PopIndent() {
            if ((this.Indents.Count == 0)) {
                return string.Empty;
            }
            int lastPos = (this.currentIndent.Length - this.Indents.Pop());
            string last = this.currentIndent.Substring(lastPos);
            this.currentIndent = this.currentIndent.Substring(0, lastPos);
            return last;
        }
        
        public void PushIndent(string indent) {
            this.Indents.Push(indent.Length);
            this.currentIndent = (this.currentIndent + indent);
        }
        
        public void ClearIndent() {
            this.currentIndent = string.Empty;
            this.Indents.Clear();
        }
        
        public void Write(string textToAppend) {
            this.GenerationEnvironment.Append(textToAppend);
        }
        
        public void Write(string format, params object[] args) {
            this.GenerationEnvironment.AppendFormat(format, args);
        }
        
        public void WriteLine(string textToAppend) {
            this.GenerationEnvironment.Append(this.currentIndent);
            this.GenerationEnvironment.AppendLine(textToAppend);
        }
        
        public void WriteLine(string format, params object[] args) {
            this.GenerationEnvironment.Append(this.currentIndent);
            this.GenerationEnvironment.AppendFormat(format, args);
            this.GenerationEnvironment.AppendLine();
        }
        
        public class ToStringInstanceHelper {
            
            private global::System.IFormatProvider formatProvider = global::System.Globalization.CultureInfo.InvariantCulture;
            
            public global::System.IFormatProvider FormatProvider {
                get {
                    return this.formatProvider;
                }
                set {
                    if ((value != null)) {
                        this.formatProvider = value;
                    }
                }
            }
            
            public string ToStringWithCulture(object objectToConvert) {
                if ((objectToConvert == null)) {
                    throw new global::System.ArgumentNullException("objectToConvert");
                }
                global::System.Type type = objectToConvert.GetType();
                global::System.Type iConvertibleType = typeof(global::System.IConvertible);
                if (iConvertibleType.IsAssignableFrom(type)) {
                    return ((global::System.IConvertible)(objectToConvert)).ToString(this.formatProvider);
                }
                global::System.Reflection.MethodInfo methInfo = type.GetMethod("ToString", new global::System.Type[] {
                            iConvertibleType});
                if ((methInfo != null)) {
                    return ((string)(methInfo.Invoke(objectToConvert, new object[] {
                                this.formatProvider})));
                }
                return objectToConvert.ToString();
            }
        }
    }
}
