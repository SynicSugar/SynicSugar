//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace SynicSugarGenerator {
    using System.Linq;
    using System.Text;
    using System.Collections.Generic;
    using Microsoft.CodeAnalysis.CSharp.Syntax;
    using System;
    
    
    public partial class ConnecthubTemplate : ConnecthubTemplateBase {
        
        public virtual string TransformText() {
            this.GenerationEnvironment = null;
            
            #line 9 ""
            this.Write("// <auto-generated>\n// THIS (.cs) FILE IS GENERATED BY SynicSugarGenerator. DO NO" +
                    "T CHANGE IT.\n// </auto-generated>\n#pragma warning disable CS0164 // This label h" +
                    "as not been referenced\n#pragma warning disable CS0436 // Type conflicts with the" +
                    " imported type\n\nusing UnityEngine;\nusing MemoryPack;\nusing MemoryPack.Compressio" +
                    "n;\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing" +
                    " Cysharp.Threading.Tasks;\nusing Epic.OnlineServices;\nusing SynicSugar.RTC;\nnames" +
                    "pace SynicSugar.P2P {\n    internal sealed class ConnectHub : IPacketConvert {\n  " +
                    "      //Singleton\n        private static Lazy<ConnectHub> instance = new Lazy<Co" +
                    "nnectHub>();\n        public static ConnectHub Instance => instance.Value;\n\n     " +
                    "   public ConnectHub(){\n            syncTokenSource = new CancellationTokenSourc" +
                    "e();\n        }\n        INetworkCore _networkCore;\n        INetworkCore NetworkCo" +
                    "re { \n            get { \n                if(_networkCore == null){\n             " +
                    "       _networkCore = p2pConnectorForOtherAssembly.GetNetworkCore();\n           " +
                    "     }\n                return _networkCore;\n            }\n        }\n        /// " +
                    "<summary>\n        /// SyncToken is managed with the connection\'s valid state.\n  " +
                    "      /// </summary>\n        CancellationTokenSource syncTokenSource;\n\n        p" +
                    "ublic CancellationToken GetSyncToken(){\n            return syncTokenSource.Token" +
                    ";\n        }\n        //Start\n        /// <summary>\n        /// Start the packet r" +
                    "eceiver. Call after creating the Network Instance required for reception.<br />\n" +
                    "        /// This cannot be called with other Receiver same time. If start the ot" +
                    "her Receiver, ConenctHub stop this Receiver automatically before start the new o" +
                    "ne.\n        /// </summary>\n        /// <param name=\"receiveTiming\">The timing th" +
                    "at packet receiver gets packet from buffer.</param>\n        /// <param name=\"max" +
                    "BatchSize\">How many times during 1 FPS are received</param>\n        public void " +
                    "StartPacketReceiver(PacketReceiveTiming receiveTiming = PacketReceiveTiming.Upda" +
                    "te, uint maxBatchSize = 1){\n        #if SYNICSUGAR_PACKETINFO\n            string" +
                    " chs = string.Empty;\n            string[] chList = Enum.GetNames(typeof(ConnectH" +
                    "ub.CHANNELLIST));\n            foreach(var l in chList){\n                chs += l" +
                    ".ToString() + \", \";\n            }\n            Debug.Log($\"ch info: amount {chLis" +
                    "t.Length} / {chs}\");\n        #endif\n            NetworkCore.StartPacketReceiver(" +
                    "this, receiveTiming, maxBatchSize);\n        }\n        \n        /// <summary>\n   " +
                    "     /// To get only SynicPacket in burst FPS. Call after creating the Network I" +
                    "nstance required for reception.<br />\n        /// This cannot be called with oth" +
                    "er Receiver same time. If start the other Receiver, ConenctHub stop this Receive" +
                    "r automatically before start the new one.\n        /// </summary>\n        /// <pa" +
                    "ram name=\"maxBatchSize\">How many times during 1 FPS are received</param>\n       " +
                    " public void StartSynicReceiver(uint maxBatchSize = 1){\n            NetworkCore." +
                    "StartSynicReceiver(this, maxBatchSize);\n        }\n        //Pause receiver\n     " +
                    "   /// <summary>\n        /// Pause getting a packet from the buffer. To re-start" +
                    ", call StartPacketReceiver().<br />\n        /// *Packet receiving to the buffer " +
                    "is continue. If the packet is over the buffer, subsequent packets are discarded." +
                    "\n        /// </summary>\n        public void PausePacketReceiver(){\n            N" +
                    "etworkCore.StopPacketReceiver();\n        }\n\n        //Pause Reciving buffer\n    " +
                    "    /// <summary>\n        /// Pause receiving a packet to the receive buffer. To" +
                    " re-start, call RestartConnections(). <br />\n        /// After call this, packet" +
                    "s will have been discarded until connection will re-open.<br />\n        /// WARN" +
                    "ING: This doesn\'t work as intended now. Can\'t stop receiving packets to buffer, " +
                    "so SynicSugar discard those packets before re-start.\n        /// </summary>\n    " +
                    "    /// <param name=\"isForced\">If True, force to stop and clear current packet q" +
                    "ueue. <br />\n        /// If false, process current queue, then stop it.</param>\n" +
                    "        public async UniTask PauseConnections(bool isForced = false, Cancellatio" +
                    "nTokenSource cancelToken = default(CancellationTokenSource)){\n            if(can" +
                    "celToken == default(CancellationTokenSource)){\n                cancelToken = new" +
                    " CancellationTokenSource();\n            }\n            syncTokenSource.Cancel();\n" +
                    "            await NetworkCore.PauseConnections(isForced, cancelToken.Token);\n   " +
                    "     }\n        /// <summary>\n        /// Prepare to receive packets in advance. " +
                    "If user sent a packet, it can also open connection to get packets without this.\n" +
                    "        /// </summary>\n        public void RestartConnections(){\n            Net" +
                    "workCore.RestartConnections();\n            syncTokenSource = new CancellationTok" +
                    "enSource();\n            StartPacketReceiver();\n        }\n        \n        /// <s" +
                    "ummary>\n        /// Stop receiver, close all connections and remove the notify e" +
                    "vents.\n        /// Then, the user leave the lobby.<br />\n        /// The last us" +
                    "er closes the lobby in Backend.\n        /// <param name=\"destroyManager\">Destroy" +
                    " NetworkManager after exit lobby.</param>\n        /// <param name=\"cancelToken\">" +
                    "Cancel token for this task</param>\n        /// </summary>\n        public async U" +
                    "niTask<Result> ExitSession(bool destroyManager = true, CancellationToken cancelT" +
                    "oken = default(CancellationToken)){\n            if(cancelToken == default(Cancel" +
                    "lationToken)){\n                cancelToken = p2pConfig.Instance.gameObject.GetCa" +
                    "ncellationTokenOnDestroy();\n            }\n            Result isSuccess = await N" +
                    "etworkCore.ExitSession(destroyManager, cancelToken);\n            syncTokenSource" +
                    ".Cancel();\n            ClearReferenceDictionaries();\n            return isSucces" +
                    "s;\n        }\n        /// <summary>\n        /// Stop receiver, close all connecti" +
                    "ons and remove the notify events.\n        /// Then, Host closes and Guest leaves" +
                    " the Lobby.<br />\n        /// When Host closes Lobby, Guests are automatically k" +
                    "icked out from the Lobby.\n        /// <param name=\"destroyManager\">Destroy Netwo" +
                    "rkManager after exit lobby.</param>\n        /// <param name=\"cancelToken\">Cancel" +
                    " token for this task</param>\n        /// </summary>\n        public async UniTask" +
                    "<Result> CloseSession(bool destroyManager = true, CancellationToken cancelToken " +
                    "= default(CancellationToken)){\n            if(cancelToken == default(Cancellatio" +
                    "nToken)){\n                cancelToken = p2pConfig.Instance.gameObject.GetCancell" +
                    "ationTokenOnDestroy();\n            }\n            Result isSuccess = await Networ" +
                    "kCore.CloseSession(destroyManager, cancelToken);\n            syncTokenSource.Can" +
                    "cel();\n            ClearReferenceDictionaries();\n            return isSuccess;\n " +
                    "       }\n\n        //(for elements)\n        public enum CHANNELLIST{\n            " +
                    "");
            
            #line default
            #line hidden
            
            #line 145 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( SyncList ));
            
            #line default
            #line hidden
            
            #line 145 ""
            this.Write(@"
        }
        //For Synic(UserId, value)
        Dictionary<string, byte[]> synicBuffer = new Dictionary<string, byte[]>();
        Dictionary<string, SynicPacketInfomation> synicPacketInfo = new Dictionary<string, SynicPacketInfomation>();

        //For LargePacket(UserId, (ch, value))
        Dictionary<string, Dictionary<byte, byte[]>> largeBuffer = new Dictionary<string,Dictionary<byte, byte[]>>();
        Dictionary<string, Dictionary<byte, LargePacketsInfomation>> largePacketInfo = new Dictionary<string, Dictionary<byte, LargePacketsInfomation>>();

        //Ref(for class)");
            
            #line default
            #line hidden
            
            #line 155 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( Reference ));
            
            #line default
            #line hidden
            
            #line 155 ""
            this.Write("\n\n        //Clear ref\n        private void ClearReferenceDictionaries(){ ");
            
            #line default
            #line hidden
            
            #line 158 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( ClearReference ));
            
            #line default
            #line hidden
            
            #line 158 ""
            this.Write("\n            synicBuffer.Clear();\n            synicPacketInfo.Clear();\n          " +
                    "  largeBuffer.Clear();\n            largePacketInfo.Clear();\n        }\n\n        /" +
                    "/Register(for class)");
            
            #line default
            #line hidden
            
            #line 165 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( Register ));
            
            #line default
            #line hidden
            
            #line 165 ""
            this.Write(@"
        
        /// <summary>
        /// Get the NetworkPlayer instance registered with ConnectHub.
        /// </summary>
        /// <param name=""id"">UserID to get</param>
        /// <returns>T's instance</returns>
        public T GetUserInstance<T>(UserId id) where T : IGetPlayer {");
            
            #line default
            #line hidden
            
            #line 172 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( PlayeInstance ));
            
            #line default
            #line hidden
            
            #line 172 ""
            this.Write(@"
            return default(T);
        }
        
        /// <summary>
        /// Get the NetworkCommons instance registered with ConnectHub.
        /// </summary>
        /// <returns>T's instance</returns>
        public T GetInstance<T>() where T : IGetCommons {");
            
            #line default
            #line hidden
            
            #line 180 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( CommonsInstance ));
            
            #line default
            #line hidden
            
            #line 180 ""
            this.Write("\n            return default(T);\n        }\n\n        //SendPacket(for elements)\n   " +
                    "     public void ConvertFromPacket(ref byte ch, string id, ref ArraySegment<byte" +
                    "> payload){\n            switch((CHANNELLIST)ch){");
            
            #line default
            #line hidden
            
            #line 186 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( PacketConvert ));
            
            #line default
            #line hidden
            
            #line 186 ""
            this.Write("\n                case CHANNELLIST.ObtainPing:\n                    EOSp2p.SendPack" +
                    "et((byte)CHANNELLIST.ReturnPong, payload, UserId.GetUserId(id));\n               " +
                    " return;\n                case CHANNELLIST.ReturnPong:\n                    Networ" +
                    "kCore.GetPong(id, payload);\n                return;\n                case CHANNEL" +
                    "LIST.Synic:\n                    bool restoredPacket = RestoreSynicPackets(ref ch" +
                    ", id, ref payload);\n                    if(!restoredPacket){\n    #if SYNICSUGAR_" +
                    "LOG \n                        Debug.LogFormat(\"ConvertFormPacket: Restore packet " +
                    "is in progress. for {0}\", id);\n    #endif\n                        return;\n      " +
                    "              }\n                    SyncedSynic(id.ToString());\n\n               " +
                    "     NetworkCore.UpdateSyncedState(id, synicPacketInfo[id].phase);\n\n            " +
                    "        //Init\n                    synicBuffer.Remove(id.ToString());\n          " +
                    "          synicPacketInfo.Remove(id.ToString());\n\n                    //Change A" +
                    "cceptHostsSynic flag.\n                    if(p2pInfo.Instance.IsLoaclUser(id)){\n" +
                    "                        NetworkCore.CloseHostSynic();\n                    }\n    " +
                    "                \n                return;\n            }\n        }\n\n        /// <s" +
                    "ummary>\n        /// Re-Send RPC with last recorded information.<br />\n        //" +
                    "/ To send disconnected peers after some time. SynicSugar retransmit to connectin" +
                    "g-peers.<br />\n        /// To record, pass true to attribute.\n        /// </summ" +
                    "ary>\n        public void ResendLastRPC(){\n            if(p2pInfo.Instance.LastRP" +
                    "CIsLargePacket){\n                EOSp2p.SendLargePacketsToAll(p2pInfo.Instance.L" +
                    "astRPCch, p2pInfo.Instance.LastRPCPayload).Forget();\n                return;\n   " +
                    "         }\n            EOSp2p.SendPacketToAll(p2pInfo.Instance.LastRPCch, p2pInf" +
                    "o.Instance.LastRPCPayload).Forget();\n        }\n        /// <summary>\n        ///" +
                    " Re-Send RPC to the specific target with last recorded information.<br />\n      " +
                    "  /// In order to send disconnected peers after the some time. SynicSugar has re" +
                    "transmission to connecting-peers for the reliability.<br />\n        /// To recor" +
                    "d, pass true to attribute.\n        /// </summary>\n        /// <param name=\"targe" +
                    "t\"></param>\n        public void ResendLastRPCToTarget(UserId target){\n          " +
                    "  if(p2pInfo.Instance.LastRPCIsLargePacket){\n                EOSp2p.SendLargePac" +
                    "kets(p2pInfo.Instance.LastRPCch, p2pInfo.Instance.LastRPCPayload, target).Forget" +
                    "();\n                return;\n            }\n            EOSp2p.SendPacket(p2pInfo." +
                    "Instance.LastRPCch, p2pInfo.Instance.LastRPCPayload, target);\n        }\n        " +
                    "/// <summary>\n        /// Re-Send TargetRPC with last recorded information.<br /" +
                    ">\n        /// In order to send disconnected peers after the some time. SynicSuga" +
                    "r has retransmission to connecting-peers for the reliability.<br />\n        /// " +
                    "To record, pass true to attribute.\n        /// </summary>\n        public void Re" +
                    "sendLastTargetRPC(){\n            if(p2pInfo.Instance.LastTargetRPCIsLargePacket)" +
                    "{\n                EOSp2p.SendLargePackets(p2pInfo.Instance.LastTargetRPCch, p2pI" +
                    "nfo.Instance.LastTargetRPCPayload, p2pInfo.Instance.LastTargetRPCUserId).Forget(" +
                    ");\n                return;\n            }\n            EOSp2p.SendPacket(p2pInfo.I" +
                    "nstance.LastTargetRPCch, p2pInfo.Instance.LastTargetRPCPayload, p2pInfo.Instance" +
                    ".LastTargetRPCUserId);\n        }\n\n        ");
            
            #line default
            #line hidden
            
            #line 256 ""
 if (needSyncSynic) { 
            
            #line default
            #line hidden
            
            #line 257 ""
            this.Write("        \n        /// <summary>\n        /// Sync all Synic variables. This is very" +
                    " heavy because it handles multiple data and repeats compression and serializatio" +
                    "n.\n        /// </summary>\n        /// <param name=\"targetId\">Target to be synced" +
                    " by this local user.</param>\n        /// /// <param name=\"type\">Whose data Host " +
                    "sends in Host\'s local. When set WithTarget or WithOthers, can overwrite the targ" +
                    "et\'s local data in Host\'s local data.</param>\n        /// <param name=\"syncedPha" +
                    "se\">Phase to be synced. If syncSinglePhase is false, sync all variables in the p" +
                    "hase up to this point.</param>\n        /// <param name=\"syncSinglePhase\">If true" +
                    ", send only variables in syncedPhase.</param>\n        public async void SyncSyni" +
                    "c(UserId targetId, SynicType type, byte syncedPhase = 9, bool syncSinglePhase = " +
                    "false){\n            //Sync local data to target local\n            SynicContainer" +
                    " synicContainer = GenerateSynicContainer(p2pInfo.Instance.LocalUserId, syncedPha" +
                    "se, syncSinglePhase);\n\n            using var selfCompressor  = new BrotliCompres" +
                    "sor();\n            MemoryPackSerializer.Serialize(selfCompressor, synicContainer" +
                    ");\n\n            EOSp2p.SendSynicPackets((byte)CHANNELLIST.Synic, selfCompressor." +
                    "ToArray(), targetId, p2pInfo.Instance.LocalUserId, syncedPhase, syncSinglePhase)" +
                    ";\n\n            if(type == SynicType.OnlySelf || !p2pInfo.Instance.IsHost()){\n   " +
                    "             return;\n            }\n            if(type == SynicType.WithOthers){" +
                    "\n                foreach(var id in p2pInfo.Instance.DisconnectedUserIds){\n      " +
                    "              synicContainer = GenerateSynicContainer(id, syncedPhase, syncSingl" +
                    "ePhase);\n\n                    using var targetCompressor  = new BrotliCompressor" +
                    "();\n                    MemoryPackSerializer.Serialize(targetCompressor, synicCo" +
                    "ntainer);\n\n                    EOSp2p.SendSynicPackets((byte)CHANNELLIST.Synic, " +
                    "targetCompressor.ToArray(), targetId, id, syncedPhase, syncSinglePhase);\n       " +
                    "             \n                    await UniTask.Yield();\n                }\n     " +
                    "       }\n            \n            //Sync target data in local to target local\n  " +
                    "          synicContainer = GenerateSynicContainer(targetId, syncedPhase, syncSin" +
                    "glePhase);\n\n            using var reconnecterCompressor  = new BrotliCompressor(" +
                    ");\n            MemoryPackSerializer.Serialize(reconnecterCompressor, synicContai" +
                    "ner);\n\n            EOSp2p.SendSynicPackets((byte)CHANNELLIST.Synic, reconnecterC" +
                    "ompressor.ToArray(), targetId, targetId, syncedPhase, syncSinglePhase);\n        " +
                    "}\n        \n        SynicContainer GenerateSynicContainer(UserId id, byte syncedP" +
                    "hase, bool syncSinglePhase){\n            SynicContainer synicContainer = new Syn" +
                    "icContainer();\n            switch(syncedPhase){");
            
            #line default
            #line hidden
            
            #line 301 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( GenerateSynicContainer ));
            
            #line default
            #line hidden
            
            #line 301 ""
            this.Write("\n                default:\n                goto case 9;\n            }\n            " +
                    "return synicContainer;\n        }\n        ");
            
            #line default
            #line hidden
            
            #line 307 ""
 } 
            
            #line default
            #line hidden
            
            #line 308 ""
            this.Write("        \n        //Synced 0 = index, 1 = additional packet amount\n        bool Re" +
                    "storeLargePackets(ref byte ch, string id, ref ArraySegment<byte> payload){\n     " +
                    "       //Prep\n            if(!largeBuffer.ContainsKey(id)){\n                larg" +
                    "ePacketInfo.Add(id, new Dictionary<byte, LargePacketsInfomation>());\n           " +
                    "     largeBuffer.Add(id, new Dictionary<byte, byte[]>());\n            }\n        " +
                    "    if(!largeBuffer[id].ContainsKey(ch)){\n                largePacketInfo[id].Ad" +
                    "d(ch, new LargePacketsInfomation(){ additionalPacketsAmount = payload[1] });\n   " +
                    "             //Prep enough byte[]\n                largeBuffer[id].Add(ch, new by" +
                    "te[(payload[1] + 1) * EOSp2p.MAX_LARGEPACKET_PAYLOADSIZE]);\n            }\n\n     " +
                    "       int packetIndex = payload[0];\n            int offset = packetIndex * EOSp" +
                    "2p.MAX_LARGEPACKET_PAYLOADSIZE;\n\n    #if SYNICSUGAR_PACKETINFO\n            Debug" +
                    ".Log($\"RestoreLargePackets: ch {ch}({(CHANNELLIST)ch}) from {id} / packet index " +
                    "{payload[0]}/{payload[1]}\");\n    #endif\n            //Remove header\n            " +
                    "Span<byte> packetPayload = payload.Slice(2);\n            largePacketInfo[id][ch]" +
                    ".currentSize += packetPayload.Length;\n            //Copy Byte from what come in\n" +
                    "            Buffer.BlockCopy(packetPayload.ToArray(), 0, largeBuffer[id][ch], of" +
                    "fset, packetPayload.Length);\n\n            //Comming all?\n            //We don\'t " +
                    "know real packet size. So we need + 1166.\n            //This first conditon for " +
                    "empty packet.\n            return largePacketInfo[id][ch].additionalPacketsAmount" +
                    " == 0 || largePacketInfo[id][ch].currentSize + EOSp2p.MAX_LARGEPACKET_PAYLOADSIZ" +
                    "E > largeBuffer[id][ch].Length ? true : false;\n        }\n\n        // 0-packet in" +
                    "dex, 1-additional packet amount, 2-complex data[1bit-isOnly, 4bits-phase, 3bits " +
                    "userType], 3-data\'s user index\n        bool RestoreSynicPackets(ref byte ch, str" +
                    "ing id, ref ArraySegment<byte> payload){\n            //Set target id\n           " +
                    " int userDataType = (int)(payload[2] & 0x07);\n            if(userDataType == 0){" +
                    "\n                if(p2pInfo.Instance.IsHost(id) && p2pInfo.Instance.IsReconnecte" +
                    "r){\n                    id = p2pInfo.Instance.LocalUserId.ToString();\n          " +
                    "      }else{\n                    return false;\n                }\n            }el" +
                    "se if(userDataType == 2){\n                if(p2pInfo.Instance.IsHost(id) && p2pI" +
                    "nfo.Instance.IsReconnecter){\n                    id = p2pInfo.Instance.AllUserId" +
                    "s[payload[3]].ToString();\n                }else{\n                    return fals" +
                    "e;\n                }\n            }\n\n            if(!synicBuffer.ContainsKey(id))" +
                    "{\n                synicPacketInfo.Add(id, new SynicPacketInfomation(){  basis = " +
                    "new (){ additionalPacketsAmount = payload[1]}, \n                                " +
                    "                                            phase = (byte)((payload[2] >> 3) & 0" +
                    "x0F), \n                                                                         " +
                    "   isSinglePhase = (payload[2] & 0x80) != 0 });\n                //Prep enough by" +
                    "te[]\n                synicBuffer.Add(id, new byte[(payload[1] + 1) * EOSp2p.MAX_" +
                    "LARGEPACKET_PAYLOADSIZE]);\n            }\n            int packetIndex = payload[0" +
                    "];\n            int offset = packetIndex * EOSp2p.MAX_LARGEPACKET_PAYLOADSIZE;\n\n " +
                    "   #if SYNICSUGAR_PACKETINFO\n            Debug.Log($\"RestoreSynicPacket(Synic): " +
                    "ch {ch}({(CHANNELLIST)ch}) / Data\'s userID {id} / packet index {payload[0]}/{pay" +
                    "load[1]}\");\n    #endif\n            //Remove header\n            Span<byte> packet" +
                    "Payload = payload.Slice(4);\n            synicPacketInfo[id].basis.currentSize +=" +
                    " packetPayload.Length;\n            //Copy Byte from what come in\n            Buf" +
                    "fer.BlockCopy(packetPayload.ToArray(), 0, synicBuffer[id], offset, packetPayload" +
                    ".Length);\n            //Comming all?\n            //We don\'t know real packet siz" +
                    "e. So we need + 1166.\n            //This first conditon for empty packet.\n      " +
                    "      return synicPacketInfo[id].basis.additionalPacketsAmount == 0 || synicPack" +
                    "etInfo[id].basis.currentSize + EOSp2p.MAX_LARGEPACKET_PAYLOADSIZE > synicBuffer[" +
                    "id].Length ? true : false;\n        }\n\n        /// <summary>\n        /// Call fro" +
                    "m ConvertFormPacket.\n        /// </summary>\n        void SyncedSynic(string over" +
                    "writerUserId){\n            //Deserialize packet\n            using var decompress" +
                    "or = new BrotliDecompressor();\n            Span<byte> transmittedPaylaod = new S" +
                    "pan<byte>(synicBuffer[overwriterUserId]);\n\n            var decompressedBuffer = " +
                    "decompressor.Decompress(transmittedPaylaod.Slice(0, synicPacketInfo[overwriterUs" +
                    "erId].basis.currentSize));\n            SynicContainer container = MemoryPackSeri" +
                    "alizer.Deserialize<SynicContainer>(decompressedBuffer);\n#if SYNICSUGAR_LOG\n     " +
                    "       Debug.Log($\"SyncedSynic: Deserialize is Success for {overwriterUserId}\");" +
                    "\n    #endif\n\n            //Packet data\n            int phase = synicPacketInfo[o" +
                    "verwriterUserId].phase;\n            bool syncSinglePhase = synicPacketInfo[overw" +
                    "riterUserId].isSinglePhase;\n\n            switch(phase){");
            
            #line default
            #line hidden
            
            #line 400 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( SyncedInvoker ));
            
            #line default
            #line hidden
            
            #line 400 ""
            this.Write("\n                default:\n                goto case 9;\n            }\n        }\n  " +
                    "      ");
            
            #line default
            #line hidden
            
            #line 405 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( SyncedItems ));
            
            #line default
            #line hidden
            
            #line 405 ""
            this.Write("\n    }\n}");
            
            #line default
            #line hidden
            return this.GenerationEnvironment.ToString();
        }
        
        public virtual void Initialize() {
        }
    }
    
    public class ConnecthubTemplateBase {
        
        private global::System.Text.StringBuilder builder;
        
        private global::System.Collections.Generic.IDictionary<string, object> session;
        
        private global::System.CodeDom.Compiler.CompilerErrorCollection errors;
        
        private string currentIndent = string.Empty;
        
        private global::System.Collections.Generic.Stack<int> indents;
        
        private ToStringInstanceHelper _toStringHelper = new ToStringInstanceHelper();
        
        public virtual global::System.Collections.Generic.IDictionary<string, object> Session {
            get {
                return this.session;
            }
            set {
                this.session = value;
            }
        }
        
        public global::System.Text.StringBuilder GenerationEnvironment {
            get {
                if ((this.builder == null)) {
                    this.builder = new global::System.Text.StringBuilder();
                }
                return this.builder;
            }
            set {
                this.builder = value;
            }
        }
        
        protected global::System.CodeDom.Compiler.CompilerErrorCollection Errors {
            get {
                if ((this.errors == null)) {
                    this.errors = new global::System.CodeDom.Compiler.CompilerErrorCollection();
                }
                return this.errors;
            }
        }
        
        public string CurrentIndent {
            get {
                return this.currentIndent;
            }
        }
        
        private global::System.Collections.Generic.Stack<int> Indents {
            get {
                if ((this.indents == null)) {
                    this.indents = new global::System.Collections.Generic.Stack<int>();
                }
                return this.indents;
            }
        }
        
        public ToStringInstanceHelper ToStringHelper {
            get {
                return this._toStringHelper;
            }
        }
        
        public void Error(string message) {
            this.Errors.Add(new global::System.CodeDom.Compiler.CompilerError(null, -1, -1, null, message));
        }
        
        public void Warning(string message) {
            global::System.CodeDom.Compiler.CompilerError val = new global::System.CodeDom.Compiler.CompilerError(null, -1, -1, null, message);
            val.IsWarning = true;
            this.Errors.Add(val);
        }
        
        public string PopIndent() {
            if ((this.Indents.Count == 0)) {
                return string.Empty;
            }
            int lastPos = (this.currentIndent.Length - this.Indents.Pop());
            string last = this.currentIndent.Substring(lastPos);
            this.currentIndent = this.currentIndent.Substring(0, lastPos);
            return last;
        }
        
        public void PushIndent(string indent) {
            this.Indents.Push(indent.Length);
            this.currentIndent = (this.currentIndent + indent);
        }
        
        public void ClearIndent() {
            this.currentIndent = string.Empty;
            this.Indents.Clear();
        }
        
        public void Write(string textToAppend) {
            this.GenerationEnvironment.Append(textToAppend);
        }
        
        public void Write(string format, params object[] args) {
            this.GenerationEnvironment.AppendFormat(format, args);
        }
        
        public void WriteLine(string textToAppend) {
            this.GenerationEnvironment.Append(this.currentIndent);
            this.GenerationEnvironment.AppendLine(textToAppend);
        }
        
        public void WriteLine(string format, params object[] args) {
            this.GenerationEnvironment.Append(this.currentIndent);
            this.GenerationEnvironment.AppendFormat(format, args);
            this.GenerationEnvironment.AppendLine();
        }
        
        public class ToStringInstanceHelper {
            
            private global::System.IFormatProvider formatProvider = global::System.Globalization.CultureInfo.InvariantCulture;
            
            public global::System.IFormatProvider FormatProvider {
                get {
                    return this.formatProvider;
                }
                set {
                    if ((value != null)) {
                        this.formatProvider = value;
                    }
                }
            }
            
            public string ToStringWithCulture(object objectToConvert) {
                if ((objectToConvert == null)) {
                    throw new global::System.ArgumentNullException("objectToConvert");
                }
                global::System.Type type = objectToConvert.GetType();
                global::System.Type iConvertibleType = typeof(global::System.IConvertible);
                if (iConvertibleType.IsAssignableFrom(type)) {
                    return ((global::System.IConvertible)(objectToConvert)).ToString(this.formatProvider);
                }
                global::System.Reflection.MethodInfo methInfo = type.GetMethod("ToString", new global::System.Type[] {
                            iConvertibleType});
                if ((methInfo != null)) {
                    return ((string)(methInfo.Invoke(objectToConvert, new object[] {
                                this.formatProvider})));
                }
                return objectToConvert.ToString();
            }
        }
    }
}
