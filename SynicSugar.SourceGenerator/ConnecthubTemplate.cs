//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace SynicSugarGenerator {
    using System.Linq;
    using System.Text;
    using System.Collections.Generic;
    using Microsoft.CodeAnalysis.CSharp.Syntax;
    using System;
    
    
    public partial class ConnecthubTemplate : ConnecthubTemplateBase {
        
        public virtual string TransformText() {
            this.GenerationEnvironment = null;
            
            #line 9 ""
            this.Write("// <auto-generated>\n// THIS (.cs) FILE IS GENERATED BY SynicSugarGenerator. DO NO" +
                    "T CHANGE IT.\n// </auto-generated>\n#pragma warning disable CS0164 // This label h" +
                    "as not been referenced\n#pragma warning disable CS0436 // Type conflicts with the" +
                    " imported type\n\nusing UnityEngine;\nusing MemoryPack;\nusing MemoryPack.Compressio" +
                    "n;\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing" +
                    " Cysharp.Threading.Tasks;\nusing Epic.OnlineServices;\nusing SynicSugar.RTC;\nnames" +
                    "pace SynicSugar.P2P {\n    internal sealed class ConnectHub : IPacketReciver {\n  " +
                    "      //Singleton\n        private static Lazy<ConnectHub> instance = new Lazy<Co" +
                    "nnectHub>();\n        public static ConnectHub Instance => instance.Value;\n\n     " +
                    "   public ConnectHub(){}\n        byte ch_r;\n        ProductUserId id_r;\n        " +
                    "ArraySegment<byte> payload_r;\n        //Start\n        /// <summary>\n        /// " +
                    "Start the packet receiver. Call after creating the Network Instance required for" +
                    " reception.<br />\n        /// This cannot be called with other Receiver same tim" +
                    "e. If start the other Receiver, ConenctHub stop this Receiver automatically befo" +
                    "re start the new one.\n        /// </summary>\n        /// <param name=\"receiveTim" +
                    "ing\">The timing that packet receiver gets packet from buffer.</param>\n        //" +
                    "/ <param name=\"maxBatchSize\">How many times during 1 FPS are received</param>\n  " +
                    "      public void StartPacketReceiver(PacketReceiveTiming receiveTiming = Packet" +
                    "ReceiveTiming.Update, byte maxBatchSize = 1){\n        #if SYNICSUGAR_PACKETINFO\n" +
                    "            string chs = string.Empty;\n            string[] chList = Enum.GetNam" +
                    "es(typeof(ConnectHub.CHANNELLIST));\n            foreach(var l in chList){\n      " +
                    "          chs += l.ToString() + \", \";\n            }\n            Debug.Log($\"ch i" +
                    "nfo: amount {chList.Length} / {chs}\");\n        #endif\n            p2pConnectorFo" +
                    "rOtherAssembly.Instance.StartPacketReceiver(this, receiveTiming, maxBatchSize);\n" +
                    "        }\n        \n        /// <summary>\n        /// To get only SynicPacket in " +
                    "burst FPS. Call after creating the Network Instance required for reception.<br /" +
                    ">\n        /// This cannot be called with other Receiver same time. If start the " +
                    "other Receiver, ConenctHub stop this Receiver automatically before start the new" +
                    " one.\n        /// </summary>\n        public void StartSynicReceiver(){\n         " +
                    "   if(p2pConnectorForOtherAssembly.Instance.p2pToken != null && !p2pConnectorFor" +
                    "OtherAssembly.Instance.p2pToken.IsCancellationRequested){\n                p2pCon" +
                    "nectorForOtherAssembly.Instance.p2pToken.Cancel();\n            }\n\n            p2" +
                    "pConnectorForOtherAssembly.Instance.p2pToken = new CancellationTokenSource();\n\n " +
                    "           ReciveSynicPackets(p2pConnectorForOtherAssembly.Instance.p2pToken.Tok" +
                    "en).Forget();\n        }\n        //Pause receiver\n        /// <summary>\n        /" +
                    "// Pause getting a packet from the buffer. To re-start, call StartPacketReceiver" +
                    "().<br />\n        /// *Packet receiving to the buffer is continue. If the packet" +
                    " is over the buffer, subsequent packets are discarded.\n        /// </summary>\n  " +
                    "      public void PausePacketReceiver(){\n            if(p2pConnectorForOtherAsse" +
                    "mbly.Instance.p2pToken != null && !p2pConnectorForOtherAssembly.Instance.p2pToke" +
                    "n.IsCancellationRequested){\n                p2pConnectorForOtherAssembly.Instanc" +
                    "e.StopPacketReceiving();\n                p2pConnectorForOtherAssembly.Instance.p" +
                    "2pToken.Cancel();\n            }\n        }\n\n        //Pause Reciving buffer\n     " +
                    "   /// <summary>\n        /// Pause receiving a packet to the receive buffer. To " +
                    "re-start, call RestartConnections(). <br />\n        /// After call this, packets" +
                    " will have been discarded until connection will re-open.<br />\n        /// WARNI" +
                    "NG: This doesn\'t work as intended now. Can\'t stop receiving packets to buffer, s" +
                    "o SynicSugar discard those packets before re-start.\n        /// </summary>\n     " +
                    "   /// <param name=\"isForced\">If True, force to stop and clear current packet qu" +
                    "eue. <br />\n        /// If false, process current queue, then stop it.</param>\n " +
                    "       public async UniTask PauseConnections(bool isForced = false, Cancellation" +
                    "TokenSource cancelToken = default(CancellationTokenSource)){\n            if(canc" +
                    "elToken == default(CancellationTokenSource)){\n                cancelToken = new " +
                    "CancellationTokenSource();\n            }\n            await p2pConnectorForOtherA" +
                    "ssembly.Instance.PauseConnections(isForced, cancelToken.Token);\n        }\n      " +
                    "  /// <summary>\n        /// Prepare to receive packets in advance. If user sent " +
                    "a packet, it can also open connection to get packets without this.\n        /// <" +
                    "/summary>\n        public void RestartConnections(){\n            p2pConnectorForO" +
                    "therAssembly.Instance.RestartConnections();\n            StartPacketReceiver();\n " +
                    "       }\n        \n        /// <summary>\n        /// Stop receiver, close all con" +
                    "nections and remove the notify events.\n        /// Then, the user leave the lobb" +
                    "y.<br />\n        /// The last user closes the lobby in Backend.\n        /// <par" +
                    "am name=\"destroyManager\">Destroy NetworkManager after exit lobby.</param>\n      " +
                    "  /// <param name=\"cancelToken\">Cancel token for this task</param>\n        /// <" +
                    "/summary>\n        public async UniTask<Result> ExitSession(bool destroyManager =" +
                    " true, CancellationToken cancelToken = default(CancellationToken)){\n            " +
                    "if(cancelToken == default(CancellationToken)){\n                cancelToken = p2p" +
                    "ConnectorForOtherAssembly.Instance.gameObject.GetCancellationTokenOnDestroy();\n " +
                    "           }\n            Result isSuccess = await p2pConnectorForOtherAssembly.I" +
                    "nstance.ExitSession(destroyManager, cancelToken);\n            ClearReferenceDict" +
                    "ionaries();\n            return isSuccess;\n        }\n        /// <summary>\n      " +
                    "  /// Stop receiver, close all connections and remove the notify events.\n       " +
                    " /// Then, Host closes and Guest leaves the Lobby.<br />\n        /// When Host c" +
                    "loses Lobby, Guests are automatically kicked out from the Lobby.\n        /// <pa" +
                    "ram name=\"destroyManager\">Destroy NetworkManager after exit lobby.</param>\n     " +
                    "   /// <param name=\"cancelToken\">Cancel token for this task</param>\n        /// " +
                    "</summary>\n        public async UniTask<Result> CloseSession(bool destroyManager" +
                    " = true, CancellationToken cancelToken = default(CancellationToken)){\n          " +
                    "  if(cancelToken == default(CancellationToken)){\n                cancelToken = p" +
                    "2pConnectorForOtherAssembly.Instance.gameObject.GetCancellationTokenOnDestroy();" +
                    "\n            }\n            Result isSuccess = await p2pConnectorForOtherAssembly" +
                    ".Instance.CloseSession(destroyManager, cancelToken);\n            ClearReferenceD" +
                    "ictionaries();\n            return isSuccess;\n        } \n\n\n        async UniTask " +
                    "ReciveSynicPackets(CancellationToken token){\n            int count = p2pConfig.I" +
                    "nstance.SynicReceiverBatchSize;\n\n            while(!token.IsCancellationRequeste" +
                    "d){\n                bool recivePacket = p2pConnectorForOtherAssembly.Instance.Ge" +
                    "tSynicPacketFromBuffer(ref ch_r, ref id_r, ref payload_r);\n                count" +
                    "--;\n\n                if(recivePacket){\n                    ConvertFromPacket(ref" +
                    " ch_r, UserId.GetUserId(id_r).ToString(), ref payload_r);\n                }\n\n   " +
                    "             if(count == 0 || !recivePacket){\n                    await UniTask." +
                    "Yield(PlayerLoopTiming.Update, cancellationToken : token);\n                    \n" +
                    "                    if(p2pConnectorForOtherAssembly.Instance == null){\n         " +
                    "               break;\n                    }\n                    count = p2pConfi" +
                    "g.Instance.SynicReceiverBatchSize;\n                }\n            }\n        }\n\n  " +
                    "      //(for elements)\n        public enum CHANNELLIST{\n            ");
            
            #line default
            #line hidden
            
            #line 156 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( SyncList ));
            
            #line default
            #line hidden
            
            #line 156 ""
            this.Write(@"
        }
        //For Synic(UserId, value)
        Dictionary<string, byte[]> synicBuffer = new Dictionary<string, byte[]>();
        Dictionary<string, SynicPacketInfomation> synicPacketInfo = new Dictionary<string, SynicPacketInfomation>();

        //For LargePacket(UserId, (ch, value))
        Dictionary<string, Dictionary<byte, byte[]>> largeBuffer = new Dictionary<string,Dictionary<byte, byte[]>>();
        Dictionary<string, Dictionary<byte, LargePacketsInfomation>> largePacketInfo = new Dictionary<string, Dictionary<byte, LargePacketsInfomation>>();

        //Ref(for class)");
            
            #line default
            #line hidden
            
            #line 166 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( Reference ));
            
            #line default
            #line hidden
            
            #line 166 ""
            this.Write("\n\n        //Clear ref\n        private void ClearReferenceDictionaries(){ ");
            
            #line default
            #line hidden
            
            #line 169 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( ClearReference ));
            
            #line default
            #line hidden
            
            #line 169 ""
            this.Write("\n            synicBuffer.Clear();\n            synicPacketInfo.Clear();\n          " +
                    "  largeBuffer.Clear();\n            largePacketInfo.Clear();\n        }\n\n        /" +
                    "/Register(for class)");
            
            #line default
            #line hidden
            
            #line 176 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( Register ));
            
            #line default
            #line hidden
            
            #line 176 ""
            this.Write(@"
        
        /// <summary>
        /// Get the NetworkPlayer instance registered with ConnectHub.
        /// </summary>
        /// <param name=""id"">UserID to get</param>
        /// <returns>T's instance</returns>
        public T GetUserInstance<T>(UserId id) where T : IGetPlayer {");
            
            #line default
            #line hidden
            
            #line 183 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( PlayeInstance ));
            
            #line default
            #line hidden
            
            #line 183 ""
            this.Write(@"
            return default(T);
        }
        
        /// <summary>
        /// Get the NetworkCommons instance registered with ConnectHub.
        /// </summary>
        /// <returns>T's instance</returns>
        public T GetInstance<T>() where T : IGetCommons {");
            
            #line default
            #line hidden
            
            #line 191 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( CommonsInstance ));
            
            #line default
            #line hidden
            
            #line 191 ""
            this.Write("\n            return default(T);\n        }\n\n        //SendPacket(for elements)\n   " +
                    "     public void ConvertFromPacket(ref byte ch, string id, ref ArraySegment<byte" +
                    "> payload){\n            switch((CHANNELLIST)ch){");
            
            #line default
            #line hidden
            
            #line 197 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( PacketConvert ));
            
            #line default
            #line hidden
            
            #line 197 ""
            this.Write("\n                case CHANNELLIST.ObtainPing:\n                    EOSp2p.SendPack" +
                    "et((byte)CHANNELLIST.ReturnPong, payload, UserId.GetUserId(id));\n               " +
                    " return;\n                case CHANNELLIST.ReturnPong:\n                    p2pCon" +
                    "nectorForOtherAssembly.Instance.GetPong(id, payload);\n                return;\n  " +
                    "              case CHANNELLIST.Synic:\n                    bool restoredPacket = " +
                    "RestoreSynicPackets(ref ch, id, ref payload);\n                    if(!restoredPa" +
                    "cket){\n    #if SYNICSUGAR_LOG \n                        Debug.LogFormat(\"ConvertF" +
                    "ormPacket: Restore packet is in progress. for {0}\", id);\n    #endif\n            " +
                    "            return;\n                    }\n                    SyncedSynic(id.ToS" +
                    "tring());\n\n                    p2pConnectorForOtherAssembly.Instance.UpdateSynce" +
                    "dState(id, synicPacketInfo[id].phase);\n\n                    //Init\n             " +
                    "       synicBuffer.Remove(id.ToString());\n                    synicPacketInfo.Re" +
                    "move(id.ToString());\n\n                    //Change AcceptHostsSynic flag.\n      " +
                    "              if(p2pInfo.Instance.IsLoaclUser(id)){\n                        p2pC" +
                    "onnectorForOtherAssembly.Instance.CloseHostSynic();\n                    }\n      " +
                    "              \n                return;\n            }\n        }\n\n        /// <sum" +
                    "mary>\n        /// Re-Send RPC with last recorded information.<br />\n        /// " +
                    "To send disconnected peers after some time. SynicSugar retransmit to connecting-" +
                    "peers.<br />\n        /// To record, pass true to attribute.\n        /// </summar" +
                    "y>\n        public void ResendLastRPC(){\n            if(p2pInfo.Instance.LastRPCI" +
                    "sLargePacket){\n                EOSp2p.SendLargePacketsToAll(p2pInfo.Instance.Las" +
                    "tRPCch, p2pInfo.Instance.LastRPCPayload).Forget();\n                return;\n     " +
                    "       }\n            EOSp2p.SendPacketToAll(p2pInfo.Instance.LastRPCch, p2pInfo." +
                    "Instance.LastRPCPayload).Forget();\n        }\n        /// <summary>\n        /// R" +
                    "e-Send RPC to the specific target with last recorded information.<br />\n        " +
                    "/// In order to send disconnected peers after the some time. SynicSugar has retr" +
                    "ansmission to connecting-peers for the reliability.<br />\n        /// To record," +
                    " pass true to attribute.\n        /// </summary>\n        /// <param name=\"target\"" +
                    "></param>\n        public void ResendLastRPCToTarget(UserId target){\n            " +
                    "if(p2pInfo.Instance.LastRPCIsLargePacket){\n                EOSp2p.SendLargePacke" +
                    "ts(p2pInfo.Instance.LastRPCch, p2pInfo.Instance.LastRPCPayload, target).Forget()" +
                    ";\n                return;\n            }\n            EOSp2p.SendPacket(p2pInfo.In" +
                    "stance.LastRPCch, p2pInfo.Instance.LastRPCPayload, target);\n        }\n        //" +
                    "/ <summary>\n        /// Re-Send TargetRPC with last recorded information.<br />\n" +
                    "        /// In order to send disconnected peers after the some time. SynicSugar " +
                    "has retransmission to connecting-peers for the reliability.<br />\n        /// To" +
                    " record, pass true to attribute.\n        /// </summary>\n        public void Rese" +
                    "ndLastTargetRPC(){\n            if(p2pInfo.Instance.LastTargetRPCIsLargePacket){\n" +
                    "                EOSp2p.SendLargePackets(p2pInfo.Instance.LastTargetRPCch, p2pInf" +
                    "o.Instance.LastTargetRPCPayload, p2pInfo.Instance.LastTargetRPCUserId).Forget();" +
                    "\n                return;\n            }\n            EOSp2p.SendPacket(p2pInfo.Ins" +
                    "tance.LastTargetRPCch, p2pInfo.Instance.LastTargetRPCPayload, p2pInfo.Instance.L" +
                    "astTargetRPCUserId);\n        }\n\n        ");
            
            #line default
            #line hidden
            
            #line 267 ""
 if (needSyncSynic) { 
            
            #line default
            #line hidden
            
            #line 268 ""
            this.Write("        \n        /// <summary>\n        /// Sync all Synic variables. This is very" +
                    " heavy because it handles multiple data and repeats compression and serializatio" +
                    "n.\n        /// </summary>\n        /// <param name=\"targetId\">Target to be synced" +
                    " by this local user.</param>\n        /// /// <param name=\"type\">Whose data Host " +
                    "sends in Host\'s local. When set WithTarget or WithOthers, can overwrite the targ" +
                    "et\'s local data in Host\'s local data.</param>\n        /// <param name=\"syncedPha" +
                    "se\">Phase to be synced. If syncSinglePhase is false, sync all variables in the p" +
                    "hase up to this point.</param>\n        /// <param name=\"syncSinglePhase\">If true" +
                    ", send only variables in syncedPhase.</param>\n        public async void SyncSyni" +
                    "c(UserId targetId, SynicType type, byte syncedPhase = 9, bool syncSinglePhase = " +
                    "false){\n            //Sync local data to target local\n            SynicContainer" +
                    " synicContainer = GenerateSynicContainer(p2pInfo.Instance.LocalUserId, syncedPha" +
                    "se, syncSinglePhase);\n\n            using var selfCompressor  = new BrotliCompres" +
                    "sor();\n            MemoryPackSerializer.Serialize(selfCompressor, synicContainer" +
                    ");\n\n            EOSp2p.SendSynicPackets((byte)CHANNELLIST.Synic, selfCompressor." +
                    "ToArray(), targetId, p2pInfo.Instance.LocalUserId, syncedPhase, syncSinglePhase)" +
                    ";\n\n            if(type == SynicType.OnlySelf || !p2pInfo.Instance.IsHost()){\n   " +
                    "             return;\n            }\n            if(type == SynicType.WithOthers){" +
                    "\n                foreach(var id in p2pInfo.Instance.DisconnectedUserIds){\n      " +
                    "              synicContainer = GenerateSynicContainer(id, syncedPhase, syncSingl" +
                    "ePhase);\n\n                    using var targetCompressor  = new BrotliCompressor" +
                    "();\n                    MemoryPackSerializer.Serialize(targetCompressor, synicCo" +
                    "ntainer);\n\n                    EOSp2p.SendSynicPackets((byte)CHANNELLIST.Synic, " +
                    "targetCompressor.ToArray(), targetId, id, syncedPhase, syncSinglePhase);\n       " +
                    "             \n                    await UniTask.Yield();\n                }\n     " +
                    "       }\n            \n            //Sync target data in local to target local\n  " +
                    "          synicContainer = GenerateSynicContainer(targetId, syncedPhase, syncSin" +
                    "glePhase);\n\n            using var reconnecterCompressor  = new BrotliCompressor(" +
                    ");\n            MemoryPackSerializer.Serialize(reconnecterCompressor, synicContai" +
                    "ner);\n\n            EOSp2p.SendSynicPackets((byte)CHANNELLIST.Synic, reconnecterC" +
                    "ompressor.ToArray(), targetId, targetId, syncedPhase, syncSinglePhase);\n        " +
                    "}\n        \n        SynicContainer GenerateSynicContainer(UserId id, byte syncedP" +
                    "hase, bool syncSinglePhase){\n            SynicContainer synicContainer = new Syn" +
                    "icContainer();\n            switch(syncedPhase){");
            
            #line default
            #line hidden
            
            #line 312 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( GenerateSynicContainer ));
            
            #line default
            #line hidden
            
            #line 312 ""
            this.Write("\n                default:\n                goto case 9;\n            }\n            " +
                    "return synicContainer;\n        }\n        ");
            
            #line default
            #line hidden
            
            #line 318 ""
 } 
            
            #line default
            #line hidden
            
            #line 319 ""
            this.Write("        \n        //Synced 0 = index, 1 = additional packet amount\n        bool Re" +
                    "storeLargePackets(ref byte ch, string id, ref ArraySegment<byte> payload){\n     " +
                    "       //Prep\n            if(!largeBuffer.ContainsKey(id)){\n                larg" +
                    "ePacketInfo.Add(id, new Dictionary<byte, LargePacketsInfomation>());\n           " +
                    "     largeBuffer.Add(id, new Dictionary<byte, byte[]>());\n            }\n        " +
                    "    if(!largeBuffer[id].ContainsKey(ch)){\n                largePacketInfo[id].Ad" +
                    "d(ch, new LargePacketsInfomation(){ additionalPacketsAmount = payload[1] });\n   " +
                    "             //Prep enough byte[]\n                largeBuffer[id].Add(ch, new by" +
                    "te[(payload[1] + 1) * EOSp2p.MAX_LARGEPACKET_PAYLOADSIZE]);\n            }\n\n     " +
                    "       int packetIndex = payload[0];\n            int offset = packetIndex * EOSp" +
                    "2p.MAX_LARGEPACKET_PAYLOADSIZE;\n\n    #if SYNICSUGAR_PACKETINFO\n            Debug" +
                    ".Log($\"RestoreLargePackets: ch {ch}({(CHANNELLIST)ch}) from {id} / packet index " +
                    "{payload[0]}/{payload[1]}\");\n    #endif\n            //Remove header\n            " +
                    "Span<byte> packetPayload = payload.Slice(2);\n            largePacketInfo[id][ch]" +
                    ".currentSize += packetPayload.Length;\n            //Copy Byte from what come in\n" +
                    "            Buffer.BlockCopy(packetPayload.ToArray(), 0, largeBuffer[id][ch], of" +
                    "fset, packetPayload.Length);\n\n            //Comming all?\n            //We don\'t " +
                    "know real packet size. So we need + 1166.\n            //This first conditon for " +
                    "empty packet.\n            return largePacketInfo[id][ch].additionalPacketsAmount" +
                    " == 0 || largePacketInfo[id][ch].currentSize + EOSp2p.MAX_LARGEPACKET_PAYLOADSIZ" +
                    "E > largeBuffer[id][ch].Length ? true : false;\n        }\n\n        // 0-packet in" +
                    "dex, 1-additional packet amount, 2-complex data[1bit-isOnly, 4bits-phase, 3bits " +
                    "userType], 3-data\'s user index\n        bool RestoreSynicPackets(ref byte ch, str" +
                    "ing id, ref ArraySegment<byte> payload){\n            //Set target id\n           " +
                    " int userDataType = (int)(payload[2] & 0x07);\n            if(userDataType == 0){" +
                    "\n                if(p2pInfo.Instance.IsHost(id) && p2pInfo.Instance.IsReconnecte" +
                    "r){\n                    id = p2pInfo.Instance.LocalUserId.ToString();\n          " +
                    "      }else{\n                    return false;\n                }\n            }el" +
                    "se if(userDataType == 2){\n                if(p2pInfo.Instance.IsHost(id) && p2pI" +
                    "nfo.Instance.IsReconnecter){\n                    id = p2pInfo.Instance.AllUserId" +
                    "s[payload[3]].ToString();\n                }else{\n                    return fals" +
                    "e;\n                }\n            }\n\n            if(!synicBuffer.ContainsKey(id))" +
                    "{\n                synicPacketInfo.Add(id, new SynicPacketInfomation(){  basis = " +
                    "new (){ additionalPacketsAmount = payload[1]}, \n                                " +
                    "                                            phase = (byte)((payload[2] >> 3) & 0" +
                    "x0F), \n                                                                         " +
                    "   isSinglePhase = (payload[2] & 0x80) != 0 });\n                //Prep enough by" +
                    "te[]\n                synicBuffer.Add(id, new byte[(payload[1] + 1) * EOSp2p.MAX_" +
                    "LARGEPACKET_PAYLOADSIZE]);\n            }\n            int packetIndex = payload[0" +
                    "];\n            int offset = packetIndex * EOSp2p.MAX_LARGEPACKET_PAYLOADSIZE;\n\n " +
                    "   #if SYNICSUGAR_PACKETINFO\n            Debug.Log($\"RestoreSynicPacket(Synic): " +
                    "ch {ch}({(CHANNELLIST)ch}) / Data\'s userID {id} / packet index {payload[0]}/{pay" +
                    "load[1]}\");\n    #endif\n            //Remove header\n            Span<byte> packet" +
                    "Payload = payload.Slice(4);\n            synicPacketInfo[id].basis.currentSize +=" +
                    " packetPayload.Length;\n            //Copy Byte from what come in\n            Buf" +
                    "fer.BlockCopy(packetPayload.ToArray(), 0, synicBuffer[id], offset, packetPayload" +
                    ".Length);\n            //Comming all?\n            //We don\'t know real packet siz" +
                    "e. So we need + 1166.\n            //This first conditon for empty packet.\n      " +
                    "      return synicPacketInfo[id].basis.additionalPacketsAmount == 0 || synicPack" +
                    "etInfo[id].basis.currentSize + EOSp2p.MAX_LARGEPACKET_PAYLOADSIZE > synicBuffer[" +
                    "id].Length ? true : false;\n        }\n\n        /// <summary>\n        /// Call fro" +
                    "m ConvertFormPacket.\n        /// </summary>\n        void SyncedSynic(string over" +
                    "writerUserId){\n            //Deserialize packet\n            using var decompress" +
                    "or = new BrotliDecompressor();\n            Span<byte> transmittedPaylaod = new S" +
                    "pan<byte>(synicBuffer[overwriterUserId]);\n\n            var decompressedBuffer = " +
                    "decompressor.Decompress(transmittedPaylaod.Slice(0, synicPacketInfo[overwriterUs" +
                    "erId].basis.currentSize));\n            SynicContainer container = MemoryPackSeri" +
                    "alizer.Deserialize<SynicContainer>(decompressedBuffer);\n#if SYNICSUGAR_LOG\n     " +
                    "       Debug.Log($\"SyncedSynic: Deserialize is Success for {overwriterUserId}\");" +
                    "\n    #endif\n\n            //Packet data\n            int phase = synicPacketInfo[o" +
                    "verwriterUserId].phase;\n            bool syncSinglePhase = synicPacketInfo[overw" +
                    "riterUserId].isSinglePhase;\n\n            switch(phase){");
            
            #line default
            #line hidden
            
            #line 411 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( SyncedInvoker ));
            
            #line default
            #line hidden
            
            #line 411 ""
            this.Write("\n                default:\n                goto case 9;\n            }\n        }\n  " +
                    "      ");
            
            #line default
            #line hidden
            
            #line 416 ""
            this.Write(this.ToStringHelper.ToStringWithCulture( SyncedItems ));
            
            #line default
            #line hidden
            
            #line 416 ""
            this.Write("\n    }\n}");
            
            #line default
            #line hidden
            return this.GenerationEnvironment.ToString();
        }
        
        public virtual void Initialize() {
        }
    }
    
    public class ConnecthubTemplateBase {
        
        private global::System.Text.StringBuilder builder;
        
        private global::System.Collections.Generic.IDictionary<string, object> session;
        
        private global::System.CodeDom.Compiler.CompilerErrorCollection errors;
        
        private string currentIndent = string.Empty;
        
        private global::System.Collections.Generic.Stack<int> indents;
        
        private ToStringInstanceHelper _toStringHelper = new ToStringInstanceHelper();
        
        public virtual global::System.Collections.Generic.IDictionary<string, object> Session {
            get {
                return this.session;
            }
            set {
                this.session = value;
            }
        }
        
        public global::System.Text.StringBuilder GenerationEnvironment {
            get {
                if ((this.builder == null)) {
                    this.builder = new global::System.Text.StringBuilder();
                }
                return this.builder;
            }
            set {
                this.builder = value;
            }
        }
        
        protected global::System.CodeDom.Compiler.CompilerErrorCollection Errors {
            get {
                if ((this.errors == null)) {
                    this.errors = new global::System.CodeDom.Compiler.CompilerErrorCollection();
                }
                return this.errors;
            }
        }
        
        public string CurrentIndent {
            get {
                return this.currentIndent;
            }
        }
        
        private global::System.Collections.Generic.Stack<int> Indents {
            get {
                if ((this.indents == null)) {
                    this.indents = new global::System.Collections.Generic.Stack<int>();
                }
                return this.indents;
            }
        }
        
        public ToStringInstanceHelper ToStringHelper {
            get {
                return this._toStringHelper;
            }
        }
        
        public void Error(string message) {
            this.Errors.Add(new global::System.CodeDom.Compiler.CompilerError(null, -1, -1, null, message));
        }
        
        public void Warning(string message) {
            global::System.CodeDom.Compiler.CompilerError val = new global::System.CodeDom.Compiler.CompilerError(null, -1, -1, null, message);
            val.IsWarning = true;
            this.Errors.Add(val);
        }
        
        public string PopIndent() {
            if ((this.Indents.Count == 0)) {
                return string.Empty;
            }
            int lastPos = (this.currentIndent.Length - this.Indents.Pop());
            string last = this.currentIndent.Substring(lastPos);
            this.currentIndent = this.currentIndent.Substring(0, lastPos);
            return last;
        }
        
        public void PushIndent(string indent) {
            this.Indents.Push(indent.Length);
            this.currentIndent = (this.currentIndent + indent);
        }
        
        public void ClearIndent() {
            this.currentIndent = string.Empty;
            this.Indents.Clear();
        }
        
        public void Write(string textToAppend) {
            this.GenerationEnvironment.Append(textToAppend);
        }
        
        public void Write(string format, params object[] args) {
            this.GenerationEnvironment.AppendFormat(format, args);
        }
        
        public void WriteLine(string textToAppend) {
            this.GenerationEnvironment.Append(this.currentIndent);
            this.GenerationEnvironment.AppendLine(textToAppend);
        }
        
        public void WriteLine(string format, params object[] args) {
            this.GenerationEnvironment.Append(this.currentIndent);
            this.GenerationEnvironment.AppendFormat(format, args);
            this.GenerationEnvironment.AppendLine();
        }
        
        public class ToStringInstanceHelper {
            
            private global::System.IFormatProvider formatProvider = global::System.Globalization.CultureInfo.InvariantCulture;
            
            public global::System.IFormatProvider FormatProvider {
                get {
                    return this.formatProvider;
                }
                set {
                    if ((value != null)) {
                        this.formatProvider = value;
                    }
                }
            }
            
            public string ToStringWithCulture(object objectToConvert) {
                if ((objectToConvert == null)) {
                    throw new global::System.ArgumentNullException("objectToConvert");
                }
                global::System.Type type = objectToConvert.GetType();
                global::System.Type iConvertibleType = typeof(global::System.IConvertible);
                if (iConvertibleType.IsAssignableFrom(type)) {
                    return ((global::System.IConvertible)(objectToConvert)).ToString(this.formatProvider);
                }
                global::System.Reflection.MethodInfo methInfo = type.GetMethod("ToString", new global::System.Type[] {
                            iConvertibleType});
                if ((methInfo != null)) {
                    return ((string)(methInfo.Invoke(objectToConvert, new object[] {
                                this.formatProvider})));
                }
                return objectToConvert.ToString();
            }
        }
    }
}
