<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.CodeAnalysis.CSharp" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Microsoft.CodeAnalysis.CSharp.Syntax" #>
<#@ output extension=".cs" #>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY SynicSugarGenerator. DO NOT CHANGE IT.
// </auto-generated>
using MemoryPack;
using System;
using System.Collections.Generic;
using System.Threading;
using Cysharp.Threading.Tasks;
namespace SynicSugar.P2P {
    internal sealed class ConnectHub {
        //Singleton
        private static Lazy<ConnectHub> instance = new Lazy<ConnectHub>();
        public static ConnectHub Instance => instance.Value;

        public ConnectHub(){
        }
        public void DisposeInstance(){
            instance = null;
        }
        //Start

        /// <summary>
        /// Start the packet receiver. Call after creating the Network Instance required for reception.
        /// </summary>
        // Default Relay Setting is AllowRelay. To change this, get NatType.
        public void StartPacketReceiver(){
            if(p2pConnectorForOtherAssembly.Instance.p2pToken == null || p2pConnectorForOtherAssembly.Instance.p2pToken.IsCancellationRequested){
                p2pConnectorForOtherAssembly.Instance.p2pToken = new CancellationTokenSource();
                RecivePacket().Forget();
            }
        }
        //Pause receiver
        /// <summary>
        /// Pause getting a packet from the buffer. To re-start, call StartPacketReceiver().<br />
        /// *Packet receiving to the buffer is continue. If the packet is over the buffer, subsequent packets are discarded.
        /// </summary>
        public void PausetPacketReceiver(){
            if(p2pConnectorForOtherAssembly.Instance.p2pToken != null && !p2pConnectorForOtherAssembly.Instance.p2pToken.IsCancellationRequested){
                p2pConnectorForOtherAssembly.Instance.p2pToken.Cancel();
            }
        }

        //Pause Recive buffer
        /// <summary>
        /// Pause receiving a packet to the receive buffer. To re-start, call ReStartPacketReceiving(). </ br>
        /// After call this, packets will have been discarded until connection will re-open.
        /// </summary>
        /// <param name="isForced">If True, force to stop and clear current packet queue. </ br>
        /// If false, process current queue, then stop it.</param>
        public async UniTask PauseSession(bool isForced, CancellationTokenSource cancelToken = default(CancellationTokenSource)){
            await p2pConnectorForOtherAssembly.Instance.PauseSession(isForced, cancelToken);
        }
        /// <summary>
        /// Prepare to receive packets in advance. If user sent a packet, it can also open connection to get packets without this.
        /// </summary>
        public void ReStartSession(){
            p2pConnectorForOtherAssembly.Instance.ReStartSession();
            RecivePacket().Forget();
        }

        //--Obsolete---
        /// <summary>
        /// Stop receiver, close all connects and cancel all events to receive. Then, exit the current lobby.<br />
        /// Fix to LeaveSession and CloseSession for readability.
        /// </summary>
        [Obsolete]
        public void EndConnection(){
            p2pConnectorForOtherAssembly.Instance.LeaveSession();
            DisposeInstance();
        }
        //----
        
        /// <summary>
        /// Stop receiver, close all connections and remove the notify events.</ br>
        /// Then, the user leave the lobby.
        /// </summary>
        public void LeaveSession(){
            p2pConnectorForOtherAssembly.Instance.LeaveSession();
            DisposeInstance();
        }
        /// <summary>
        /// Stop receiver, close all connections and remove the notify events.
        /// Then, Host closees and Guest leaves the lobby.</ br>
        /// </summary>
        public void CloseSession(){
            p2pConnectorForOtherAssembly.Instance.LeaveSession();
            DisposeInstance();
        }
        async UniTask RecivePacket(){
            while(!p2pConnectorForOtherAssembly.Instance.p2pToken.IsCancellationRequested){
                SugarPacket recivePacket = p2pConnectorForOtherAssembly.Instance.GetPacketFromBuffer();

                if(recivePacket != null){
                    ConnectHub.Instance.ConvertFormPacket(recivePacket);
                }
                await UniTask.Delay(p2pConnectorForOtherAssembly.Instance.receiverInterval, cancellationToken: p2pConnectorForOtherAssembly.Instance.p2pToken.Token);
            }
        }

        //(for elements)
        public enum CHANNELLIST{
            <#= SyncList #>
        }
        //Ref(for class)<#= Reference #>

        //Register(for class)<#= Register #>

        //GetInstance(with class instance) Good performance in IL2cpp?<#= GetInstance #>
        //GetInstance(with <type>) Bad performance in IL2cpp?
        // For Player
        public T GetUserInstance<T>(UserId id) where T : IGetPlayer {<#= PlayeInstance #>
            return default(T);
        }
        // For Commons
        public T GetUserInstance<T>() where T : IGetCommons {<#= CommonsInstance #>
            return default(T);
        }

        //GetInstanceAsObject(for class)
        public object GetUserInstanceAsObject(UserId id, Type type){<#= GetInstanceAsObject #>
            return null;
        }

        //SendPacket(for elements)
        public void ConvertFormPacket(SugarPacket packet){
            switch((CHANNELLIST)packet.ch){<#= PacketConvert #>
            }
        }
    }
}