<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.CodeAnalysis.CSharp" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Microsoft.CodeAnalysis.CSharp.Syntax" #>
<#@ output extension=".cs" #>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY SynicSugarGenerator. DO NOT CHANGE IT.
// </auto-generated>
using MemoryPack;
using System;
using System.Collections.Generic;
using System.Threading;
using Cysharp.Threading.Tasks;
namespace SynicSugar.P2P {
    internal sealed class ConnectHub {
        //Singleton
        private static Lazy<ConnectHub> instance = new Lazy<ConnectHub>();
        public static ConnectHub Instance => instance.Value;

        public ConnectHub(){
        }
        public void DisposeInstance(){
            instance = null;
        }

        /// <summary>
        /// Start the packet receiver. Call after creating the Network Instance required for reception.
        /// </summary>
        // Default Relay Setting is AllowRelay. To change this, get NatType.
        public void StartPacketReceiver(){
            if(p2pManager.Instance.p2pToken == null || p2pManager.Instance.p2pToken.IsCancellationRequested){
                p2pManager.Instance.p2pToken = new CancellationTokenSource();
                RecivePacket().Forget();
            }
        }
        /// <summary>
        /// Pause to get a packet from the buffer.<br />
        /// *Receiving to the receive buffer is continue. If the packet is over the buffer, subsequent packets are discarded.
        /// </summary>
        public void PausePacketReceiver(){
            if(p2pManager.Instance.p2pToken != null && !p2pManager.Instance.p2pToken.IsCancellationRequested){
                p2pManager.Instance.p2pToken.Cancel();
            }
        }
        /// <summary>
        /// Stop receiver, close all connects and cancel all events to receive.<br />
        /// Then, exit the current lobby.
        /// </summary>
        public void EndConnection(){
            p2pManager.Instance.EndConnection();
            DisposeInstance();
        }
        async UniTask RecivePacket(){
            while(!p2pManager.Instance.p2pToken.IsCancellationRequested){
                SugarPacket recivePacket = p2pManager.Instance.GetPacketFromBuffer();

                if(recivePacket != null){
                    ConnectHub.Instance.ConvertFormPacket(recivePacket);
                }
                await UniTask.Delay(p2pManager.Instance.delay_receive, cancellationToken: p2pManager.Instance.p2pToken.Token);
            }
        }

        //(for elements)
        public enum CHANNELLIST{
            <#= SyncList #>
        }
        //Ref(for class)<#= Reference #>

        //Register(for class)<#= Register #>

        //GetInstance(with class instance) Good performance in IL2cpp?<#= GetInstance #>
        //GetInstance(with <type>) Bad performance in IL2cpp?
        // For Player
        public T GetUserInstance<T>(UserId id) where T : IGetPlayer {<#= PlayeInstance #>
            return default(T);
        }
        // For Commons
        public T GetUserInstance<T>() where T : IGetCommons {<#= CommonsInstance #>
            return default(T);
        }

        //GetInstanceAsObject(for class)
        public object GetUserInstanceAsObject(UserId id, Type type){<#= GetInstanceAsObject #>
            return null;
        }

        //SendPacket(for elements)
        public void ConvertFormPacket(SugarPacket packet){
            switch((CHANNELLIST)packet.ch){<#= PacketConvert #>
            }
        }
    }
}