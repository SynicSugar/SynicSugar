<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.CodeAnalysis.CSharp" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Microsoft.CodeAnalysis.CSharp.Syntax" #>
<#@ output extension=".cs" #>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY SynicSugarGenerator. DO NOT CHANGE IT.
// </auto-generated>
#pragma warning disable CS0164 // This label has not been referenced
#pragma warning disable CS0436 // Type conflicts with the imported type

using UnityEngine;
using MemoryPack;
using MemoryPack.Compression;
using System;
using System.Linq;
using System.Collections.Generic;
using System.Threading;
using Cysharp.Threading.Tasks;
namespace SynicSugar.P2P {
    internal sealed class ConnectHub {
        //Singleton
        private static Lazy<ConnectHub> instance = new Lazy<ConnectHub>();
        public static ConnectHub Instance => instance.Value;

        private ConnectHub(){
        }
        //Start
        /// <summary>
        /// Start the packet receiver. Call after creating the Network Instance required for reception.
        /// </summary>
        // Default Relay Setting is AllowRelay. To change this, get NatType.
        public void StartPacketReceiver(){
            if(p2pConnectorForOtherAssembly.Instance.p2pToken == null || p2pConnectorForOtherAssembly.Instance.p2pToken.IsCancellationRequested){
                p2pConnectorForOtherAssembly.Instance.p2pToken = new CancellationTokenSource();
                RecivePacket().Forget();
            }
        }
        //Pause receiver
        /// <summary>
        /// Pause getting a packet from the buffer. To re-start, call StartPacketReceiver().<br />
        /// *Packet receiving to the buffer is continue. If the packet is over the buffer, subsequent packets are discarded.
        /// </summary>
        public void PausetPacketReceiver(){
            if(p2pConnectorForOtherAssembly.Instance.p2pToken != null && !p2pConnectorForOtherAssembly.Instance.p2pToken.IsCancellationRequested){
                p2pConnectorForOtherAssembly.Instance.p2pToken.Cancel();
            }
        }

        //Pause Reciving buffer
        /// <summary>
        /// Pause receiving a packet to the receive buffer. To re-start, call RestartConnections(). <br />
        /// After call this, packets will have been discarded until connection will re-open.<br />
        /// WARNING: This doesn't work as intended now. Can't stop receiving packets to buffer, so SynicSugar discard those packets before re-start.
        /// </summary>
        /// <param name="isForced">If True, force to stop and clear current packet queue. <br />
        /// If false, process current queue, then stop it.</param>
        public async UniTask PauseConnections(bool isForced = false, CancellationTokenSource cancelToken = default(CancellationTokenSource)){
            await p2pConnectorForOtherAssembly.Instance.PauseConnections(isForced, cancelToken);
        }
        /// <summary>
        /// Prepare to receive packets in advance. If user sent a packet, it can also open connection to get packets without this.
        /// </summary>
        public void RestartConnections(){
            p2pConnectorForOtherAssembly.Instance.RestartConnections();
            RecivePacket().Forget();
        }
        
        /// <summary>
        /// Stop receiver, close all connections and remove the notify events.
        /// Then, the user leave the lobby.<br />
        /// To exit from lobby alone during a game(= not whole, only one battle). Usually use CloseSession().
        /// </summary>
        public async UniTask<bool> ExitSession(CancellationTokenSource cancelToken = default(CancellationTokenSource)){
            bool isSuccess = await p2pConnectorForOtherAssembly.Instance.ExitSession(cancelToken.Token);
            return isSuccess;
        }
        /// <summary>
        /// Stop receiver, close all connections and remove the notify events.<br />
        /// Then, Host closees and Guest leaves the lobby.
        /// </summary>
        public async UniTask<bool> CloseSession(CancellationTokenSource cancelToken = default(CancellationTokenSource)){
            bool isSuccess = await p2pConnectorForOtherAssembly.Instance.CloseSession(cancelToken.Token);
            return isSuccess;
        }
        async UniTask RecivePacket(){
            while(!p2pConnectorForOtherAssembly.Instance.p2pToken.IsCancellationRequested){
                SugarPacket recivePacket = p2pConnectorForOtherAssembly.Instance.GetPacketFromBuffer();

                if(recivePacket != null){
                    ConnectHub.Instance.ConvertFormPacket(recivePacket);
                }
                await UniTask.Delay(p2pConnectorForOtherAssembly.Instance.receiverInterval);

                if(p2pConnectorForOtherAssembly.Instance.p2pToken.IsCancellationRequested){
                    break;
                }
            }
        }

        //(for elements)
        public enum CHANNELLIST{
            <#= SyncList #>
        }
        //Ref(for class)<#= Reference #>

        //Register(for class)<#= Register #>
        
        /// <summary>
        /// Get the NetworkPlayer instance registered with ConnectHub.
        /// </summary>
        /// <param name="id">UserID to get</param>
        /// <returns>T's instance</returns>
        public T GetUserInstance<T>(UserId id) where T : IGetPlayer {<#= PlayeInstance #>
            return default(T);
        }
        
        /// <summary>
        /// Get the NetworkCommons instance registered with ConnectHub.
        /// </summary>
        /// <returns>T's instance</returns>
        public T GetInstance<T>() where T : IGetCommons {<#= CommonsInstance #>
            return default(T);
        }

        //SendPacket(for elements)
        public void ConvertFormPacket(SugarPacket packet){
            switch((CHANNELLIST)packet.ch){<#= PacketConvert #>
            }
        }

        //For Synic
        Dictionary<string, List<ArraySegment<byte>>> buffer = new Dictionary<string, List<ArraySegment<byte>>>();
        Dictionary<string, LargePacketInfomation> packetInfo = new Dictionary<string, LargePacketInfomation>();
        /// <summary>
        /// Sync all Synic variables. This is very heavy because it handles multiple data and repeats compression and serialization.
        /// </summary>
        /// <param name="targetId">Target to be synced by this local user.</param>
        /// <param name="syncedHierarchy">Hierarchy to be synced. If syncSingleHierarchy is false, sync all variables in the hierarchy up to this point.</param>
        /// <param name="syncSingleHierarchy">If true, send only variables in syncedHierarchy.</param>
        public void SyncSynic(UserId targetId, byte syncedHierarchy = 9, bool syncSingleHierarchy = false){
            SynicContainer synicContainer = new SynicContainer();
            switch(syncedHierarchy){<#= SyncSynic #>
                default:
                goto case 9;
            }
            using var compressor  = new BrotliCompressor();
            MemoryPackSerializer.Serialize(compressor , synicContainer);

            EOSp2p.SendLargePacket((byte)CHANNELLIST.Synic, compressor.ToArray(), targetId, syncedHierarchy, syncSingleHierarchy);
        }
        
        byte[] RestorePackets(SugarPacket packet){
            if(!buffer.ContainsKey(packet.UserID)){
                buffer.Add(packet.UserID, new List<ArraySegment<byte>>());
                packetInfo.Add(packet.UserID, new LargePacketInfomation());
            }
            int packetIndex = packet.payload[0];
            bool isFirstPacket = packetIndex == 0;
            if(isFirstPacket){
                packetInfo[packet.UserID].chunk = packet.payload[1];
                packetInfo[packet.UserID].hierarchy = packet.payload[2];
                packetInfo[packet.UserID].syncSpecificHierarchy = packet.payload[3] == 1 ? true : false;
            }

            RemoveLargePacketHeader(ref packet.payload, isFirstPacket);

            //Hold packet in order
            if(packetIndex == buffer[packet.UserID].Count - 1){ //same with length 
                buffer[packet.UserID].Add(packet.payload);
            }else if(packetIndex >= buffer[packet.UserID].Count){
                for(int length = buffer[packet.UserID].Count; length <= packetIndex; length++){ //short
                    buffer[packet.UserID].Add(new ArraySegment<byte>());
                }
            }else{ //enough
                buffer[packet.UserID][packetIndex] = packet.payload;
            }

            //Restore packet
            if(buffer[packet.UserID].Count == packetInfo[packet.UserID].chunk){
                int length = buffer[packet.UserID].Sum(segment => segment.Count);
                byte[] result = new byte[length];
                int offset = 0;

                foreach (var i in buffer[packet.UserID]){
                    i.Array.CopyTo(result, offset);
                    offset += i.Count;
                }
                return result;
            }
            return null;
            
            void RemoveLargePacketHeader(ref ArraySegment<byte> payload, bool isFirst){
                if(isFirst){
                    payload = payload.Slice(4);
                }else{
                    payload = payload.Slice(1);
                }
            }
        }
        /// <summary>
        /// Call from ConvertFormPacket.
        /// </summary>
        void SyncedSynic(UserId targetId, byte[] restoredPacket){
            //Deserialize packet
            using var decompressor = new BrotliDecompressor();
            var decompressedBuffer = decompressor.Decompress(restoredPacket);
            SynicContainer container = MemoryPackSerializer.Deserialize<SynicContainer>(decompressedBuffer);

            //Packet data
            int hierarchy = packetInfo[targetId.ToString()].hierarchy;
            bool syncSingleHierarchy = packetInfo[targetId.ToString()].syncSpecificHierarchy;

            switch(hierarchy){<#= SyncedInvoker #>
                default:
                goto case 9;
            }
        }
        <#= SyncedItems #>
    }
}