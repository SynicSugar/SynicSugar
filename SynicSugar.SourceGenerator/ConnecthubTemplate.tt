<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.CodeAnalysis.CSharp" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Microsoft.CodeAnalysis.CSharp.Syntax" #>
<#@ output extension=".cs" #>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY SynicSugarGenerator. DO NOT CHANGE IT.
// </auto-generated>
#pragma warning disable CS0164 // This label has not been referenced
#pragma warning disable CS0436 // Type conflicts with the imported type

using UnityEngine;
using MemoryPack;
using MemoryPack.Compression;
using System;
using System.Collections.Generic;
using System.Threading;
using Cysharp.Threading.Tasks;
using SynicSugar.RTC;
namespace SynicSugar.P2P {
    internal sealed class ConnectHub {
        //Singleton
        private static Lazy<ConnectHub> instance = new Lazy<ConnectHub>();
        public static ConnectHub Instance => instance.Value;

        public ConnectHub(){}
        byte ch_r;
        string id_r;
        ArraySegment<byte> payload_r;
        //Start
        /// <summary>
        /// Start the packet receiver. Call after creating the Network Instance required for reception.
        /// </summary>
        // Default Relay Setting is AllowRelay. To change this, get NatType.
        public void StartPacketReceiver(){
            if(p2pConnectorForOtherAssembly.Instance.p2pToken != null && !p2pConnectorForOtherAssembly.Instance.p2pToken.IsCancellationRequested){
                p2pConnectorForOtherAssembly.Instance.p2pToken.Cancel();
            }

            p2pConnectorForOtherAssembly.Instance.p2pToken = new CancellationTokenSource();

            if(p2pConfig.Instance.AutoRefreshPing){
                p2pConnectorForOtherAssembly.Instance.AutoRefreshPings(p2pConnectorForOtherAssembly.Instance.p2pToken.Token).Forget();
            }

            if(p2pConfig.Instance.getPacketFrequency == p2pConfig.GetPacketFrequency.PerSecondBurstFPS){
                ReciveMultiplePackets().Forget();
            }else{
                RecivePacket().Forget();
            }
            if(p2pConnectorForOtherAssembly.Instance.IsEnableRTC){
                RTCManager.Instance.ToggleReceiveingFromTarget(null, true);
            }
        }
        //Pause receiver
        /// <summary>
        /// Pause getting a packet from the buffer. To re-start, call StartPacketReceiver().<br />
        /// *Packet receiving to the buffer is continue. If the packet is over the buffer, subsequent packets are discarded.
        /// </summary>
        public void PausetPacketReceiver(){
            if(p2pConnectorForOtherAssembly.Instance.p2pToken != null && !p2pConnectorForOtherAssembly.Instance.p2pToken.IsCancellationRequested){
                p2pConnectorForOtherAssembly.Instance.p2pToken.Cancel();
            }
        }

        //Pause Reciving buffer
        /// <summary>
        /// Pause receiving a packet to the receive buffer. To re-start, call RestartConnections(). <br />
        /// After call this, packets will have been discarded until connection will re-open.<br />
        /// WARNING: This doesn't work as intended now. Can't stop receiving packets to buffer, so SynicSugar discard those packets before re-start.
        /// </summary>
        /// <param name="isForced">If True, force to stop and clear current packet queue. <br />
        /// If false, process current queue, then stop it.</param>
        public async UniTask PauseConnections(bool isForced = false, CancellationTokenSource cancelToken = default(CancellationTokenSource)){
            if(cancelToken == default(CancellationTokenSource)){
                cancelToken = new CancellationTokenSource();
            }
            await p2pConnectorForOtherAssembly.Instance.PauseConnections(isForced, cancelToken.Token);
        }
        /// <summary>
        /// Prepare to receive packets in advance. If user sent a packet, it can also open connection to get packets without this.
        /// </summary>
        public void RestartConnections(){
            p2pConnectorForOtherAssembly.Instance.RestartConnections();
            StartPacketReceiver();
        }
        
        /// <summary>
        /// Stop receiver, close all connections and remove the notify events.
        /// Then, the user leave the lobby.<br />
        /// To exit from lobby alone during a game(= not whole, only one battle). Usually use CloseSession().
        /// </summary>
        public async UniTask<bool> ExitSession(CancellationTokenSource cancelToken = default(CancellationTokenSource)){
            if(cancelToken == default(CancellationTokenSource)){
                cancelToken = new CancellationTokenSource();
            }
            bool isSuccess = await p2pConnectorForOtherAssembly.Instance.ExitSession(cancelToken.Token);
            ClearReferenceDictionaries();
            return isSuccess;
        }
        /// <summary>
        /// Stop receiver, close all connections and remove the notify events.<br />
        /// Then, Host closees and Guest leaves the lobby.
        /// </summary>
        public async UniTask<bool> CloseSession(CancellationTokenSource cancelToken = default(CancellationTokenSource)){
            if(cancelToken == default(CancellationTokenSource)){
                cancelToken = new CancellationTokenSource();
            }
            bool isSuccess = await p2pConnectorForOtherAssembly.Instance.CloseSession(cancelToken.Token);
            ClearReferenceDictionaries();
            return isSuccess;
        }
        async UniTask RecivePacket(){
            while(!p2pConnectorForOtherAssembly.Instance.p2pToken.IsCancellationRequested){
                bool recivePacket = p2pConnectorForOtherAssembly.Instance.GetPacketFromBuffer(ref ch_r, ref id_r, ref payload_r);

                if(recivePacket){
                    ConnectHub.Instance.ConvertFromPacket(ref ch_r, ref id_r, ref payload_r);
                }
                await UniTask.Delay(p2pConnectorForOtherAssembly.Instance.receiverInterval);

                if(p2pConnectorForOtherAssembly.Instance == null || p2pConnectorForOtherAssembly.Instance.p2pToken.IsCancellationRequested){
                    break;
                }
            }
        }
        
        async UniTask ReciveMultiplePackets(){
            int count = p2pConfig.Instance.BurstReceiveBatchSize;

            while(!p2pConnectorForOtherAssembly.Instance.p2pToken.IsCancellationRequested){
                bool recivePacket = p2pConnectorForOtherAssembly.Instance.GetPacketFromBuffer(ref ch_r, ref id_r, ref payload_r);
                count--;

                if(recivePacket){
                    ConnectHub.Instance.ConvertFromPacket(ref ch_r, ref id_r, ref payload_r);
                }

                if(count == 0 || !recivePacket){
                    await UniTask.Yield(PlayerLoopTiming.Update);
                    
                    if(p2pConnectorForOtherAssembly.Instance == null){
                        break;
                    }
                    count = p2pConfig.Instance.BurstReceiveBatchSize;
                }
            }
        }

        //(for elements)
        public enum CHANNELLIST{
            <#= SyncList #>
        }
        //For Synic(UserId, value)
        Dictionary<string, byte[]> synicBuffer = new Dictionary<string, byte[]>();
        Dictionary<string, SynicPacketInfomation> synicPacketInfo = new Dictionary<string, SynicPacketInfomation>();

        //For LargePacket(UserId, (ch, value))
        Dictionary<string, Dictionary<byte, byte[]>> largeBuffer = new Dictionary<string,Dictionary<byte, byte[]>>();
        Dictionary<string, Dictionary<byte, LargePacketsInfomation>> largePacketInfo = new Dictionary<string, Dictionary<byte, LargePacketsInfomation>>();

        //Ref(for class)<#= Reference #>

        //Clear ref
        private void ClearReferenceDictionaries(){ <#= ClearReference #>
            synicBuffer.Clear();
            synicPacketInfo.Clear();
            largeBuffer.Clear();
            largePacketInfo.Clear();
        }

        //Register(for class)<#= Register #>
        
        /// <summary>
        /// Get the NetworkPlayer instance registered with ConnectHub.
        /// </summary>
        /// <param name="id">UserID to get</param>
        /// <returns>T's instance</returns>
        public T GetUserInstance<T>(UserId id) where T : IGetPlayer {<#= PlayeInstance #>
            return default(T);
        }
        
        /// <summary>
        /// Get the NetworkCommons instance registered with ConnectHub.
        /// </summary>
        /// <returns>T's instance</returns>
        public T GetInstance<T>() where T : IGetCommons {<#= CommonsInstance #>
            return default(T);
        }

        //SendPacket(for elements)
        public void ConvertFromPacket(ref byte ch, ref string id, ref ArraySegment<byte> payload){
            switch((CHANNELLIST)ch){<#= PacketConvert #>
                case CHANNELLIST.ObtainPing:
                    EOSp2p.SendPacket((byte)CHANNELLIST.ReturnPong, payload, UserId.GetUserId(id));
                return;
                case CHANNELLIST.ReturnPong:
                    p2pConnectorForOtherAssembly.Instance.GetPong(id, payload);
                return;
                case CHANNELLIST.Synic:
                    bool restoredPacket = RestoreSynicPackets(ref ch, ref id, ref payload);
                    if(!restoredPacket){
    #if SYNICSUGAR_LOG 
                        Debug.LogFormat("ConvertFormPacket: Restore packet is in progress. for {0}", id);
    #endif
                        return;
                    }
                    SyncedSynic(id);

                    p2pConnectorForOtherAssembly.Instance.UpdateSyncedState(id, synicPacketInfo[id].phase);

                    //Init
                    synicBuffer.Remove(id);
                    synicPacketInfo.Remove(id);

                    //Change AcceptHostsSynic flag.
                    if(p2pInfo.Instance.IsLoaclUser(id)){
                        p2pConnectorForOtherAssembly.Instance.CloseHostSynic();
                    }
                    
                return;
            }
        }

        /// <summary>
        /// Re-Send RPC with last recorded information.<br />
        /// To send disconnected peers after some time. SynicSugar retransmit to connecting-peers.<br />
        /// To record, pass true to attribute.
        /// </summary>
        public void ResendLastRPC(){
            if(p2pInfo.Instance.LastRPCIsLargePacket){
                EOSp2p.SendLargePacketsToAll(p2pInfo.Instance.LastRPCch, p2pInfo.Instance.LastRPCPayload).Forget();
                return;
            }
            EOSp2p.SendPacketToAll(p2pInfo.Instance.LastRPCch, p2pInfo.Instance.LastRPCPayload).Forget();
        }
        /// <summary>
        /// Re-Send RPC to the specific target with last recorded information.<br />
        /// In order to send disconnected peers after the some time. SynicSugar has retransmission to connecting-peers for the reliability.<br />
        /// To record, pass true to attribute.
        /// </summary>
        /// <param name="target"></param>
        public void ResendLastRPCToTarget(UserId target){
            if(p2pInfo.Instance.LastRPCIsLargePacket){
                EOSp2p.SendLargePackets(p2pInfo.Instance.LastRPCch, p2pInfo.Instance.LastRPCPayload, target).Forget();
                return;
            }
            EOSp2p.SendPacket(p2pInfo.Instance.LastRPCch, p2pInfo.Instance.LastRPCPayload, target);
        }
        /// <summary>
        /// Re-Send TargetRPC with last recorded information.<br />
        /// In order to send disconnected peers after the some time. SynicSugar has retransmission to connecting-peers for the reliability.<br />
        /// To record, pass true to attribute.
        /// </summary>
        public void ResendLastTargetRPC(){
            if(p2pInfo.Instance.LastTargetRPCIsLargePacket){
                EOSp2p.SendLargePackets(p2pInfo.Instance.LastTargetRPCch, p2pInfo.Instance.LastTargetRPCPayload, p2pInfo.Instance.LastTargetRPCUserId).Forget();
                return;
            }
            EOSp2p.SendPacket(p2pInfo.Instance.LastTargetRPCch, p2pInfo.Instance.LastTargetRPCPayload, p2pInfo.Instance.LastTargetRPCUserId);
        }

        <# if (needSyncSynic) { #>

        /// <summary>
        /// Sync all Synic variables. This is very heavy because it handles multiple data and repeats compression and serialization.
        /// </summary>
        /// <param name="targetId">Target to be synced by this local user.</param>
        /// <param name="syncedPhase">Phase to be synced. If syncSinglePhase is false, sync all variables in the phase up to this point.</param>
        /// <param name="syncSinglePhase">If true, send only variables in syncedPhase.</param>
        /// <param name="syncTargetsData">If true, sync target's data in Host local. When the target AllowHostsSynic, can overwrite the target's data in that local only once.</param>
        public void SyncSynic(UserId targetId, byte syncedPhase = 9, bool syncSinglePhase = false, bool syncTargetsData = true){
            //Sync local data to target local
            SynicContainer synicContainer = GenerateSynicContainer(p2pInfo.Instance.LocalUserId, syncedPhase, syncSinglePhase);

            using var selfCompressor  = new BrotliCompressor();
            MemoryPackSerializer.Serialize(selfCompressor, synicContainer);

            EOSp2p.SendSynicPackets((byte)CHANNELLIST.Synic, selfCompressor.ToArray(), targetId, syncedPhase, syncSinglePhase);

            if(!syncTargetsData || !p2pInfo.Instance.IsHost()){
                return;
            }
            //Sync target data in local to target local

            synicContainer = GenerateSynicContainer(targetId, syncedPhase, syncSinglePhase);

            using var targetCompressor  = new BrotliCompressor();
            MemoryPackSerializer.Serialize(targetCompressor, synicContainer);

            EOSp2p.SendSynicPackets((byte)CHANNELLIST.Synic, targetCompressor.ToArray(), targetId, syncedPhase, syncSinglePhase, false);
        }

        <#= GenerateSynicContainer #>
        <# } #>
        
        //Synced 0 = index, 1 = chunk
        bool RestoreLargePackets(ref byte ch, ref string id, ref ArraySegment<byte> payload){
            //Prep
            if(!largeBuffer.ContainsKey(id)){
                largePacketInfo.Add(id, new Dictionary<byte, LargePacketsInfomation>());
                largeBuffer.Add(id, new Dictionary<byte, byte[]>());
            }
            if(!largeBuffer[id].ContainsKey(ch)){
                largePacketInfo[id].Add(ch, new LargePacketsInfomation(){ chunk = payload[1] });
                //Prep enough byte[]
                largeBuffer[id].Add(ch, new byte[payload[1] * 1160]);
            }

            int packetIndex = payload[0];
            int offset = packetIndex * 1160;

    #if SYNICSUGAR_LOG
            Debug.Log($"RestoreLargePackets: PacketInfo:: ch {ch} / index {payload[0]} / chunk {payload[1]}");
    #endif
            //Remove header
            Span<byte> packetPayload = payload.Slice(2);
            largePacketInfo[id][ch].currentSize += packetPayload.Length;
            //Copy Byte from what come in
            Buffer.BlockCopy(packetPayload.ToArray(), 0, largeBuffer[id][ch], offset, packetPayload.Length);

            //Comming all?
            return largePacketInfo[id][ch].currentSize + 1160 > largeBuffer[id][ch].Length ? true : false;
        }

        //Synced 0 = index, 1 = chunk, 2 = phase, 3 = syncSinglePhase, 4 = isSelf
        bool RestoreSynicPackets(ref byte ch, ref string id, ref ArraySegment<byte> payload){
            if(payload[4] == 0){
                if(p2pInfo.Instance.IsHost(id) && p2pInfo.Instance.AcceptHostSynic){
                    id = p2pInfo.Instance.LocalUserId.ToString();
                }else{
                    return false;
                }
            }

            if(!synicBuffer.ContainsKey(id)){
                synicPacketInfo.Add(id, new SynicPacketInfomation(){  basis = new (){ chunk = payload[1]}, 
                                                                            phase = payload[2], 
                                                                            syncSinglePhase = payload[3] == 1 ? true : false });
                //Prep enough byte[]
                synicBuffer.Add(id, new byte[payload[1] * 1160]);
            }
            int packetIndex = payload[0];
            int offset = packetIndex * 1160;

    #if SYNICSUGAR_LOG
            Debug.Log($"RestoreSynicPackets: PacketInfo:: index {payload[0]} / chunk {payload[1]} / phase {payload[2]} / syncSinglePhase {payload[3]}");
    #endif
            //Remove header
            Span<byte> packetPayload = payload.Slice(5);
            synicPacketInfo[id].basis.currentSize += packetPayload.Length;
            //Copy Byte from what come in
            Buffer.BlockCopy(packetPayload.ToArray(), 0, synicBuffer[id], offset, packetPayload.Length);
            //Comming all?
            return synicPacketInfo[id].basis.currentSize + 1160 > synicBuffer[id].Length ? true : false;
        }

        /// <summary>
        /// Call from ConvertFormPacket.
        /// </summary>
        void SyncedSynic(string overwriterUserId){
            //Deserialize packet
            using var decompressor = new BrotliDecompressor();
            Span<byte> transmittedPaylaod = new Span<byte>(synicBuffer[overwriterUserId]);

            var decompressedBuffer = decompressor.Decompress(transmittedPaylaod.Slice(0, synicPacketInfo[overwriterUserId].basis.currentSize));
            SynicContainer container = MemoryPackSerializer.Deserialize<SynicContainer>(decompressedBuffer);
#if SYNICSUGAR_LOG
            Debug.Log($"SyncedSynic: Deserialize is Success for {overwriterUserId}");
    #endif

            //Packet data
            int phase = synicPacketInfo[overwriterUserId].phase;
            bool syncSinglePhase = synicPacketInfo[overwriterUserId].syncSinglePhase;

            switch(phase){<#= SyncedInvoker #>
                default:
                goto case 9;
            }
        }
        <#= SyncedItems #>
    }
}